---
layout: page
title: 재현가능한 과학적 분석을 위한 R
subtitle: 자료구조
minutes: 45
---

```{r, include=FALSE}
source("tools/chunk-options.R")
```


> ## 학습 목표 {.objectives}
>
> - 다양한 자료형에 대해 인지한다.
> - R에서 흔히 마주하는 다양한 기본 자료구조에 대해 인지한다.
> - 자료형, 클래스, 객체 구조에 관해 파악하고자 R에 질문을 던진다.
>

## 자료형

어떤 자료를 분석하기 전에, 기본 자료형과 자료구조에 관해 매우 잘 이해할 필요가 있다.
기본 자료형과 자료구조를 이해하는 것은 **매우 중요**하다.
이유는 R로 매일 솜씨있게 조작하는 것이고, 초보자에게 있어 가장 혼란을 많이 주는 원천이기 때문이다.

R에는 5가지 원자 자료형(더이상 작은 것으로 쪼갤 수 없다는 의미)이 있다:


* 논리형 (예를 들어, `TRUE`, `FALSE`)
* 숫자형
    * 정수형 (예를 들어, `2L`, `as.integer(3)`)
    * 실수형 (즉, 소수점) (예를 들어, `-24.57`, `2.0`, `pi`)
* 복소수형 (즉. 복소수) (예를 들어, `1 + 0i`, `1 + 4i`)
* 텍스트 (R에서는 "문자(character"라고 부름) (예를 들어, `"a"`, `"swc"`, `'This is a cat'`)

R에는 데이터를 취조하여 자료형을 파악하는데 사용되는 함수가 몇가지 있다:

```{r, eval=FALSE}
typeof() # 해당 데이터의 원자 자료형이 무엇인가?
is.logical() # TRUE/FALSE 논리형 데이터인가?
is.numeric() # 숫자형 데이터인가?
is.integer() # 정수형 데이터인가?
is.complex() # 복소수형 데이터인가?
is.character() # 문자형 데이터인가?
str()  # 데이터가 뭔지 모르겠다?
```

> ## 도전과제 1: 자료형 {.challenge}
>
> 지금까지 지식을 총동원해서 변수에 값을 대입한다.
> 다음 특징을 갖는 데이터 예제를 생성한다:
>
> 1) 변수명: 'answer', 자료형: 논리형
> 2) 변수명: 'height', 자료형: 숫자형
> 3) 변수명: 'dog_name', 자료형: 문자형
>
> 생성한 각 변수에 대해서, 의도한 데이터가 생성되었는지 테스트한다.
> 예상한지 못한 것을 발견했는가?
>

## 자료구조

R에서 흔히 마주치는 5가지 자료구조가 있다: 

* 벡터(vector)
* 요인(factor)
* 리스트(list)
* 행렬(matrix)
* 데이터프레임(data.frame)

지금은 좀더 구체적으로 벡터만 집중한다. 이유는 자료형에 대해 더 많이 파악할 수 있기 때문이다.

## 벡터

벡터는 R에서 가장 흔한 기본 자료구조이며 R의 주된 동력원이기도 하다.
원자 벡터로도 종종 불리는데, 이유는 중요하게 **단지 한가지 자료형만 포함할** 수 있기 때문이다.
벡터는 다른 자료구조의 중요 구성요소다.

젝터는 앞에서 소개한 5가지 어떤 자료형도 포함할 수 있다:

* 논리형 (예를 들어, `TRUE`, `FALSE`)
* 정수형 (예를 들어, `2L`, `as.integer(3)`)
* 숫자형 (실수 혹은 소수점) (예를 들어, `2`, `2.0`, `pi`)
* 복소수 (예를 들어, `1 + 0i`, `1 + 4i`)
* 문자형 (예를 들어, `"a"`, `"swc"`)

> ## Tip: "문자 벡터" {.callout}
>
> "문자 벡터" 용어를 경고나 오류 메시지에서 들어봤을 수도 있다. 
> 다소 혼동스럽고, 불운한 명칭이다.
> "문자" 형은 정말 텍스트를 인용부호로 감싼 것을 의미한다는 것을 기억한다.
>

`vector()` 으로 혹은 연결(concatenate) 함수, `c()`로 공벡터를 생성한다.

```{r}
x <- vector()
x
```

그래서, 기본디폴트 설정으로, "논리" 자료형을 갖는 공벡터(즉, 길이 0)를 생성한다.

```{r}
x <- vector(length = 10) # 사전에 정의된 길이
x
```

`FALSE` 갯수를 세면, 10 이 된다.

```{r}
x <- vector("character", length = 10)  # 서전에 정의된 길이와 자료형
x
```

혹은, 연결함수를 사용해서 벡터에 원하는 어떤 값도 결합할 수 있다
(동일한 원자 자료형이기만 하면 된다!).

```{r}
x <- c(10, 12, 45, 33)
x
```

연속된 숫자로 벡터를 생성할 수도 있다.

```{r}
series <- 1:10
series
```

```{r}
seq(10)
```

```{r}
seq(1, 10, by = 0.1)
```

> ## Tip: 정수 생성하기 {.callout}
>
> 연결함수, `c()`를 사용해서 숫자를 결합할 때,
> 자료형은 자동적으로 "숫자형", 즉 실수/소수점 숫자다.
> 명확하게, 정수형(자연수만) 벡터를 생성하려면, 각 숫자에 L을 추가한다.
> 즉, `c(10L, 12L, 45L, 33L)`.
>

연결함수를 사용해서 벡터에 요소를 추가할 수도 있다:

```{r}
x <- c(x, 57)
x
```

> ## 도전과제 2 {.challenge}
>
> 벡터에는 한가지 원자 자료형만 담길 수 있다.
> 만약 다른 자료형을 조합하려하면, 
> R은 최소공배수(가장 쉽게 강제해서 우겨넣을 수 있는 자료형) 벡터를 생성한다.
>
> **우선 실행하지 말고, 다음 명령어가 어떤 작업을 수행할지 추측해 보라:**
>
> ```{r, eval=FALSE}
> xx <- c(1.7, "a")
> xx <- c(TRUE, 2)
> xx <- c("a", TRUE)
> ```
>

이것을 묵시적 강제(implicit coerction)라고 부른다.

강제규칙은 다음과 같이 적용된다: `논리형` -> `정수형` -> `숫자형` -> `복소수형` ->
`문자형`.

명시적으로 `as.<class_name>`을 사용해서 벡터를 강제할 수도 있다. 예를 들어,

```{r}
as.numeric()
as.character()
```

R은 자동으로 해당 값에 대해 가장 유의미한 어떤 작업도 수행하려 한다:

```{r}
as.character(x)
```

```{r}
as.complex(x)
```

```{r}
x <- 0:6
as.logical(x)
```

이런 점은 많은 프로그래밍 언어에서도 발견되는 특징이다.
0 은 `FALSE`가 되고 다른 숫자는 `TRUE`로 처리된다.
종종 강제조차도 터무니 없는 것에는 동작하지 않는다.

일부 경우에, R은 유의미한 어떤 작업을 수행할 수도 없다:

```{r}
x <- c("a", "b", "c")
as.numeric(x)
as.logical(x)
```

양쪽 모든 경우에, "NA" 벡터가 반환된다. 
첫번째 경우는 경고도 출력된다.

> ## Tip: 특수 객체 {.callout}
>
> "NA"는 R에 있어 특수 객체로 결측값을 표기한다.
> NA 는 벡터 어떤 자료형에도 생겨난다.
> 다른 특수 객체 자료형도 있다:
> `Inf` 는 무한을 표기한다(양수 혹은 음수가 될 수 있다).
> 반면에 `NaN`은 "Not a Number", 정의되지 않는 값(즉, `0/0`)을 의미한다.
> `NULL`은 자료구조가 존재하지 않음(하지만, 리스트 요소로 사용될 수 있음)을 표기한다.
>

벡터 자료구조에 관해서 질문을 던질 수 있다:

```{r}
x <- 0:10
tail(x, n=2) # 마지막 'n' 번째 요소를 뽑아낸다.
```

```{r}
head(x, n=1) # 첫 'n' 번째 요소를 뽑아낸다.
```

```{r}
length(x)
```

```{r}
str(x)
```

벡터에 명칭을 붙일 수 있다:

```{r}
x <- 1:4
names(x) <- c("a", "b", "c", "d")
x
```

> ## 프로그래머를 위한 고급 Tip {.callout}
>
> 다른 프로그래밍 언어를 경험했다면, 
> 딕셔너리와 해쉬 테이블과 유사한 유용한 도구로 인식할 수도 있다.
> 작은 벡터에 대해서는 사실이지만, 정말 해쉬 테이블 기능을 사용하려면,
> 환경 객체를 사용해야만 된다. 
> `?new.env`을 참조한다.
>

## 행렬

마주칠 것 같은 또다른 자료구조가 행렬이다.
행렬을 까면, 차원 속성이 추가된 정말 원자벡터만 나온다. 

`matrix` 함수로 행렬을 생성한다.
임의 난수 데이터를 생성해보자:

```{r}
set.seed(1) # 난수 생성이 매번 실행될 때마다 같도록 고정시키는 역할을 한다.
x <- matrix(rnorm(18), ncol=6, nrow=3)
x
```

```{r}
str(x)
```

 `rownames`, `colnames`, `dimnames`을 사용해서
 행렬 행과 칼럼 명칭을 설정하거나 불러온다.
 `nrow`, `ncol` 함수(데이터프레임에도 적용됨!)는 행과 열의 갯수를 일러준다.
 반면에, `length` 함수는 요소 갯수를 일러준다.

>
> ## 도전과제 3 {.challenge}
>
> `length(x)` 결과는 무엇이라고 생각합니까?
> 직접 실행해 보세요. 맞췄나요? 왜 그런지/ 왜 그렇지 않나요?
>

>
> ## 도전과제 4 {.challenge}
>
> 또다른 행렬을 생성한다.
> 이번에는 1:50 까지 숫자를 포함하는 10 개 행과 5 개 칼럼을 갖춘다.
> `matrix` 함수는 기본디폴트로 처음 생성시 행과 열로 행렬을 채울 수 있나요?
> 행렬 변경에 대한 방법을 해결할 수 있는지 살펴보라.
> (**힌트:** `matrix`에 대한 문서를 읽어보다!)
>

## 요인



Factors are special vectors that represent categorical data. Factors can be
ordered or unordered and are important when for modeling functions such as
`aov()`, `lm()` and `glm()` and also in plot methods.

Factors can only contain predefined values, and we can create one with the
`factor` function:

```{r}
x <- factor(c("yes", "no", "no", "yes", "yes"))
x
```

So we can see that the output is very similar to a character vector, but with an
attached levels component. This becomes clearer when we look at its structure:

```{r}
str(x)
```

This reveals something important: while factors look (and often behave) like
character vectors, they are actually integers under the hood, and here, we can
see that "no" is represented by a 1, and "yes" a 2.

In modeling functions, important to know what baseline levels is.  This is the
first factor but by default the ordering is determined by alphabetical order of
words entered. You can change this by specifying the levels:

```{r}
x <- factor(c("case", "control", "control", "case"), levels = c("control", "case"))
str(x)
```

In this case, we've explicitly told R that "control" should represented by 1, and
"case" by 2. This designation can be very important for interpreting the
results of statistical models!

## Lists

If you want to combine different types of data, you will need to use lists.
Lists act as containers, and can contain any type of data structure, even
themselves!

Lists can be created using `list` or coerced from other objects using `as.list()`:

```{r}
x <- list(1, "a", TRUE, 1+4i)
x
```

Each element of the list is denoted by a `[[` in the output. Inside
each list element is an atomic vector of length one containing

Lists can contain more complex objects:

```{r}
xlist <- list(a = "Research Bazaar", b = 1:10, data = head(iris))
xlist
```

In this case our list contains a character vector of length one,
a numeric vector with 10 entries, and a small data frame from
one of R's many preloaded datasets (see `?data`). We've also given
each list element a name, which is why you see `$a` instead of `[[1]]`.

Lists can also contain themselves:

```{r}
list(list(list(list())))
```

> ## Challenge 5 {.challenge}
>
> Create a list of length two containing a character vector for each of the 
> sections in this part of the workshop:
>
> * Data types
> * Data structures
>
> Populate each character vector with the names of the data types and data
> structures we've seen so far.
>

Lists are extremely useful inside functions. You can "staple" together lots of
different kinds of results into a single object that a function can return. In
fact many R functions which return complex output store their results in a list.

## Challenge solutions

> ## Solution to challenge 1: Data types {.challenge}
>
> Use your knowledge of how to assign a value to
> a variable, to create examples of data with the
> following characteristics:
>
> 1) Variable name: 'answer', Type: logical
> 2) Variable name: 'height', Type: numeric
> 3) Variable name: 'dog_name', Type: character
>
> For each variable you've created, test that it
> has the data type you intended. Do you find
> anything unexpected?
>
> ```{r}
> answer <- TRUE
> height <- 150
> dog_name <- "Snoopy"
> is.logical(answer)
> ```
>
> ```{r}
> is.numeric(height)
> ```
>
> ```{r}
> is.character(dog_name)
> ```
>

> ## Solution to challenge 2 {.challenge}
>
> Vectors can only contain one atomic type. If you try to combine different
> types, R will create a vector that is the least common denominator: the
> type that is easiest to coerce to.
>
> ```{r}
> xx <- c(1.7, "a")
> xx
> typeof(xx)
> ```
>
> ```{r}
> xx <- c(TRUE, 2)
> xx
> typeof(xx)
> ```
>
> ```{r}
> xx <- c("a", TRUE)
> xx
> typeof(xx)
> ```
>

>
> ## Solution to challenge 3 {.challenge}
>
> What do you think will be the result of
> `length(x)`?
>
> ```{r}
> x <- matrix(rnorm(18), ncol=6, nrow=3)
> length(x)
> ```
> 
> Because a matrix is really just a vector with added dimension attributes, `length`
> gives you the total number of elements in the matrix.
>

>
> ## Solution to challenge 4 {.challenge}
>
> Make another matrix, this time containing the numbers 1:50,
> with 5 columns and 10 rows.
> Did the `matrix` function fill your matrix by column, or by
> row, as its default behaviour?
> See if you can figure out how to change this.
> (hint: read the documentation for `matrix`!)
>
> ```{r, eval=FALSE}
> x <- matrix(1:50, ncol=5, nrow=10)
> x <- matrix(1:50, ncol=5, nrow=10, byrow = TRUE) # to fill by row
> ```
>


> ## Solution to challenge 5 {.challenge}
>
> Create a list of length two containing a character vector for each of the 
> sections in this part of the workshop:
>
> * Data types
> * Data structures
>
> Populate each character vector with the names of the data types and data
> structures we've seen so far.
>
> ```{r, eval=FALSE}
> my_list <- list(
>   data_types = c("logical", "integer", "double", "complex", "character"),
>   data_structures = c("vector", "matrix", "factor", "list")
> )
> ```
>
