---
layout: page
title: 재현가능한 과학적 분석을 위한 R
subtitle: 데이터 부분집합
minutes: 45
---

```{r, include=FALSE}
source("tools/chunk-options.R")
# Silently load in the data so the rest of the lesson works
gapminder <- read.csv("data/gapminder-FiveYearData.csv", header=TRUE)
```

> ## 학습 목표 {.objectives}
>
> * 벡터, 요인, 행렬, 리스트, 데이터프레임 부분집합을 뽑아낼 수 있다.
> * 개별, 다수 요소를 다음 기준으로 뽑아낼 수 있다:
>     * 색인
>     * 명칭
>     * 비교 연산을 사용
> * 다양한 자료구조로부터 요소를 건너뛰거나 제거할 수 있다.
>

R에는 강력한 부분집합 연산자를 다수 구비되어 있다.
이를 완전히 익히게 되면 어떤 유형의 데이터셋에 대해서도 복잡한 연산을 수월하게 수행할 수 있게 된다.

어떤 유형의 객체에서 부분집합을 뽑아낼 수 있는 방식은  6가지가 있다.
다른 자료구조에 대한 부분집합을 뽑아내는 연산자는 3가지가 있다.

R의 핵심으로 가장 많은 일은 하는 것부터 시작해본다: 원자 벡터(atomic vector) 

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
x
```

이제 작업할 준비가 마루타 벡터를 생성했다. 해당 벡터 내용물을 손에 넣는 방식은 무엇인가?

## 색인을 사용한 요소 접근

벡터 요소를 추출하는데, 대응되는 색인을 부여하는데, 1부터 시작된다:

```{r}
x[1]
```

```{r}
x[4]
```

꺾쇠 괄호 연산자는 다른 어떤 함수와 비슷한다.
원자 벡터(그리과 행렬)에 대해, "n번째 요소를 뽑아낸다"라는 의미다.

한번에 다수 요소를 뽑아낼 수도 있다:

```{r}
x[c(1, 3)]
```

혹은, 벡터 슬라이스로 뽑아낼 수도 있다:

```{r}
x[1:4]
```

`:` 연산자는 왼쪽 요소부터 우측 요소까지 연속된 숫자를 생성한다.
예를 들어, `x[1:4]` 은 `x[c(1,2,3,4)]`와 동등하다:

```{r}
x[c(1,1,3)]
```

벡터를 벗어난 숫자를 뽑아내려고 하면, R은 결측값을 반환한다:

```{r}
x[6]
```

길이 1을 갖는 벡터로 `NA`가 담겨있고, 명칭도 `NA`다.

0번째 요소를 뽑아내려고 하면, 공벡터가 반환된다:

```{r}
x[0]
```

> ## R에서 벡터 번호매기는 것은 1에서 시작 {.callout} 
> 
> 대다수 프로그래밍 언어(C와 파이썬)에서, 벡터 첫번째 요소는 색인 0을 갖는다.
> R에서, 첫번째 요소는 1이다.

## 요소 건너뛰고 제거하기

벡터 색인으로 음수를 사용하면, R은 명세된 숫자를 제외한 모든 요소를 반환한다:

```{r}
x[-2]
```

다수 요소를 건너뛸 수도 있다:

```{r}
x[c(-1, -5)]  # 혹은 x[-c(1,5)]
```

> ## Tip: 연산작업 순서 {.callout}
>
> 초보자가 범하는 일반적인 실수는 벡터 슬라이스 건너뛰기 연산을 시도할 때 일어나다.
> 먼저 사람 대부분은 순열을 다음과 같이 부정연산을 통해 변경하려 한다:
>
> ```{r, error=TRUE}
> x[-1:3]
> ```
>
> 다소 암호스런 오류가 제시된다:
>
> 하지만, 연산작업 우선수위를 기억해보자.
> `:` 연산자는 사실 함수다.
> 그래서, 일어난 상황은 -1을 첫번째 인자로 받고, 두번째 인자로 3을 받아서,
> 연속된 숫자를 생성해낸다: `c(-1, 0, 1, 2, 3)`.
>
> 올바른 해법은 함수 호출을 괄호로 감싸는 것이다.
> `-` 연산자가 결과를 도출한다:
>
> ```{r}
> x[-(1:3)]
> ```
>

벡터에서 요소를 제거하려면, 결과를 다시 벡터에 대입할 필요가 있다:

```{r}
x <- x[-4]
x
```

> ## 도전 과제 1 {.challenge}
>
> 다음과 같이 코드가 주어졌다:
>
> ```{.r}
> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
> names(x) <- c('a', 'b', 'c', 'd', 'e')
> print(x)
> ```
>
> 1. 다음 출력과를 산출하는 적어도 서로 다른 명령어를 제시한다:
>
> ```{.r, echo=FALSE}
> x[2:4]
> ```
>
> 2. 작업결과를 옆 사람과 비교한다. 서로 다른 전략을 취했나요?
>

## 명칭으로 부분집합 뽑아내기

색인 대신에 명칭을 사용해서, 요소를 뽑아낼 수 있다:

```{r}
x[c("a", "c")]
```

명칭을 사용한 것이 객체에 대한 부분집합을 뽑아내는 훨씬 더 신뢰성 있는 방식이다:
다양한 요소 위치는 부분집합을 뽑아내는 연산자를 연결해서 적용할 때 종종 변경되지만,
명칭은 항상 동일하게 남게 마련이다!

불행하게도, 그다지 수월하게 요소를 건너뛰거나 제거할 수는 없다.

요소 하나를 건너뛰거나 제거하려면:

```{r}
x[-which(names(x) == "a")]
```

`which` 함수는 함수 인자의 모든 `TRUE` 요소에 대한 색인을 반환한다.
함수에 전달되기 전에 표현식이 평가됨을 기억한다.
내부를 파고들어, 어떤 일이 진행되는지 명확히 알아보자.

다음이 가장 먼저 진행된다:

```{r}
names(x) == "a"
```

조건 연산자는 `x` 벡터에 대한 모든 명칭에 적용된다.
첫번째 명칭만 "a" 라서, 해당 요소만 참(TRUE)이 된다.

그리고 나면, `which`가 이를 색인으로 변환한다:

```{r}
which(names(x) == "a")
```

첫번째 요소만 `참(TRUE)`이라서, `which`는 1을 반환한다.
이제 색인을 갖게 되서, 건너뛰는 연산이 동작한다. 왜냐하면 음수 색인이기 때문이다!

명칭을 갖는 다수 색인을 건너뛰는 것도 유사하다. 하지만, 다른 비교 연산자를 사용한다:

```{r}
x[-which(names(x) %in% c("a", "c"))]
```

`%in%` 비교연산자는 좌측 인자(이번 경우에, `x` 명칭)에 대한 각 요소를 훑는다.
그리고 나서, "해당 요소가 두번째 인자에 나타나는가?"라고 질의한다.

> ## 도전과제 2 {.challenge}
>
> 
> Run the following code to define vector `x` as above:
>
> ```{.r}
> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
> names(x) <- c('a', 'b', 'c', 'd', 'e')
> print(x)
> ```
>
> Given this vector `x`, what would you expect the following to do?
>```{.r, eval=FALSE}
> x[-which(names(x) == "g")]
>```
>
> Try out this command and see what you get. Did this match your expectation?
> Why did we get this result? (Tip: test out each part of the command on it's own like we just did above - this is a useful debugging strategy)
>
> Which of the following are true:
>
> * A) if there are no `TRUE` values passed to `which`, an empty vector is returned
> * B) if there are no `TRUE` values passed to `which`, an error message is shown
> * C) `integer()` is an empty vector
> * D) making an empty vector negative produces an "everything" vector
> * E) `x[]` gives the same result as `x[integer()]`
>

> ## Tip: 유일무이하지 않은 명칭 {.callout}
>
> 벡터에 요소 다수가 동일 명칭을 갖을 수 있음에 유의해야만 된다.
> (데이터프레임에서,  칼럼이 동일한 명칭을 갖을 수 있다 --- 
> R이 이런 점을 회피하려고 하지만 --- 하지만, 행 명칭은 유일무이해야 된다.)
> 다음 예제를 고려해보자:

>```{r}
> x <- 1:3
> x
> names(x) <- c('a', 'a', 'a')  
> x
> x['a']  # 첫번째 값만 반환한다.
> x[which(names(x) == 'a')]  # 세가지 값 모두 반환한다.
> ```



> ## Tip: 연산자에 대한 도움말 얻기 {.callout}
>
> 인용부호 내부에 찾고자 하는 연산자를 감싸서 도움말을 검색할 수 있다:
> `help("%in%")` 혹은 `?"%in%"`.
>

그러면, 이전처럼 `==` 연산자는 왜 사용할 수 없을까? 매우 좋은 질문이다.

비교에 해당되는 항목만 살펴보자:

```{r}
names(x) == c('a', 'c')
```

분명히, "c"는 `x` 요소명칭 중에 존재한다. 그런데, 왜 동작을 하지 않을까?
`==`은 `%in%` 과는 다소 다른방식으로 동작한다.
`==`은 좌측 인자 요소 각각을 대응되는 우측 요소 각각과 비교한다.

`==` 연산자를 모사한 것이 다음에 나와 있다:

```{r, eval=FALSE}
c("a", "b", "c", "e")  # x 명칭
   |    |    |    |    # ==으로 요소들을 비교한다.
c("a", "c")
```

한 벡터가 다른 벡터보다 작은 경우, 해당 벡터는 *재사용*된다:

```{r, eval=FALSE}
c("a", "b", "c", "e")  # x 명칭
   |    |    |    |    # ==으로 요소들을 비교한다.
c("a", "c", "a", "c")
```

이런 경우, R이 단순히 `c("a", "c")`을 두번 반복한다.
더 긴 벡터가 더 짧은 벡터의 배수가 아닌 경우, 
R은 경고 메시지도 출력한다:

```{r}
names(x) == c('a', 'c', 'e')
```

 `==` 와 `%in%` 차이점을 숙지하는 것이 중요한데,
 이유는 탐지가 어렵고 미묘한 버그가 스며들 수 있기 때문이다!

## 논리 연산자를 통한 부분집합 뽑아내기

더 단순하게는 논리 연산자로 부분집합을 뽑아낼 수도 있다:

```{r}
x[c(TRUE, TRUE, FALSE, FALSE)]
```

이번 경우, 논리 벡터는 부분집합을 뽑아내는 벡터 길이만큼 재사용됨에 주목한다!

```{r}
x[c(TRUE, FALSE)]
```

비교 연산자는 논리벡터로 평가되기 때문에, 간결하게 벡터 부분집합을 뽑아내는데 사용할 수도 있다:

```{r}
x[x > 7]
```

> ## Tip: 논리 연산자 연쇄 체인 구성{.callout}
>
> 다수 조건을 조합하고자 하는 상황이 많이 있다.
> 이런 작업을 수행하는데 필요한 논리 연산자가 R에서 지원된다:
>
>  * `|` 논리 OR: 왼쪽 오른쪽 어느 한쪽이 `TRUE`면, `TRUE`를 반환한다.
>  * `&` 논리 AND: 왼쪽 오른쪽 모두가 `TRUE`면, `TRUE`를 반환한다.
>  * `!` 논리 NOT: `TRUE`는 `FALSE`로, `FALSE`는 `TRUE`로 전환한다.
>  * `&&` , `||` 은 두 벡터의 개별 요소를 비교한다. 재활용 규칙은 이곳도 적용된다.
>

> ## 도전과제 3 {.challenge}
>
> 다음 코드가 주어졌다:
>
> ```{r}
> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
> names(x) <- c('a', 'b', 'c', 'd', 'e')
> print(x)
> ```
>
> `x` 벡터에서 4보다 크고 7보다 적은 값을 부분집합으로 뽑아내는 명령어를 작성한다.
>

## 특수값 처리하기

어느 지점에 다다르면, R 함수에 처리할 수 없는 결측값, 무한값, 정의되지 않는 값을 갖는 데이터와 마주하게 된다.

이런 유형의 데이터를 필터링하는데 사용되는 특수 함수가 있다:

 * `is.na`는 벡터, 행렬, 데이터프레임에 포함된 `NA` 위치를 반환한다.
 * 마찬가지로, `is.nan` 와 `is.infinite` 함수도 `NaN` 와 `Inf` 값에 대한 동일한 작업을 수행한다.
 * `is.finite` 함수는 `NA`, `NaN`, `Inf` 값을 포함하지 않는 벡터, 행렬, 데이터프레임에 대한 모든 위치정보를 반환한다.
   * `na.omit`는 벡터에서 모든 결측값을 필터링해서 제외시키다.

## 요인 부분집합으로 뽑아내기

지금까지 벡터 부분집합을 뽑아내는 다양한 방식을 탐색했다.
다른 자료구조에 대한 부분집합은 어떻게 뽑아낼 수 있을까?

요인 부분집합 뽑아내기는 벡터 부분집합 뽑아내기와 동일한 방식으로 동작한다.

```{r}
f <- factor(c("a", "a", "b", "c", "c", "d"))
f[f == "a"]
f[f %in% c("b", "c")]
f[1:3]
```

중요한 주의점 하나는 건너뛰는 요소가 설사 해당 범주가 요인으로 존재하지 않더라도, 
수준(level)을 제거하지 않는다는 점이다:

```{r}
f[-3]
```

## 행렬 부분집합 뽑아내기



Matrices are also subsetted using the `[` function. In this case
it takes two arguments: the first applying to the rows, the second
to its columns:

```{r}
set.seed(1)
m <- matrix(rnorm(6*4), ncol=4, nrow=6)
m[3:4, c(3,1)]
```

You can leave the first or second arguments blank to retrieve all the
rows or columns respectively:

```{r}
m[, c(3,4)]
```

If we only access one row or column, R will automatically convert the result
to a vector:

```{r}
m[3,]
```

If you want to keep the output as a matrix, you need to specify a *third* argument;
`drop = FALSE`:

```{r}
m[3, , drop=FALSE]
```

Unlike vectors, if we try to access a row or column outside of the matrix,
R will throw an error:

```{r}
m[, c(3,6)]
```

> ## Tip: Higher dimensional arrays {.callout}
>
> when dealing with multi-dimensional arrays, each argument to `[`
> corresponds to a dimension. For example, a 3D array, the first three
> arguments correspond to the rows, columns, and depth dimension.
>

Because matrices are really just vectors underneath the hood, we can
also subset using only one argument:

```{r}
m[5]
```


This usually isn't useful. However it is useful to note that matrices
are laid out in *column-major format* by default. That is the elements of the
vector are arranged column-wise:

```{r}
matrix(1:6, nrow=2, ncol=3)
```

If you wish to populate the matrix by row, use `byrow=TRUE`:

```{r}
matrix(1:6, nrow=2, ncol=3, byrow=TRUE)
```

Matrices can also be subsetted using their rownames and column names
instead of their row and column indices.

> ## Challenge 4 {.challenge}
>
> Given the following code:
>
> ```{r}
> m <- matrix(1:18, nrow=3, ncol=6)
> print(m)
> ```
>
> 1. Which of the following commands will extract the values 11 and 14?
>
> A. `m[2,4,2,5]`
>
> B. `m[2:5]`
>
> C. `m[4:5,2]`
>
> D. `m[2,c(4,5)]`
>


## List subsetting

Now we'll introduce some new subsetting operators. There are three functions
used to subset lists. `[`, as we've seen for atomic vectors and matrices,
as well as `[[` and `$`.

Using `[` will always return a list. If you want to *subset* a list, but not
*extract* an element, then you will likely use `[`.

```{r}
xlist <- list(a = "Software Carpentry", b = 1:10, data = head(iris))
xlist[1]
```

This returns a *list with one element*.

We can subset elements of a list exactly the same was as atomic
vectors using `[`. Comparison operations however won't work as
they're not recursive, they will try to condition on the data structures
in each element of the list, not the individual elements within those
data structures.

```{r}
xlist[1:2]
```

To extract individual elements of a list, you need to use the double-square
bracket function: `[[`.

```{r}
xlist[[1]]
```

Notice that now the result is a vector, not a list.

You can't extract more than one element at once:

```{r, error=TRUE}
xlist[[1:2]]
```

Nor use it to skip elements:

```{r, error=TRUE}
xlist[[-1]]
```

But you can use names to both subset and extract elements:

```{r}
xlist[["a"]]
```

The `$` function is a shorthand way for extracting elements by name:

```{r}
xlist$data
```

> ## Challenge 5 {.challenge}
> Given the following list:
>
> ```{r, eval=FALSE}
> xlist <- list(a = "Software Carpentry", b = 1:10, data = head(iris))
> ```
>
> Using your knowledge of both list and vector subsetting, extract the number 2 from xlist. 
> Hint: the number 2 is contained within the "b" item in the list.

> ## Challenge 6 {.challenge}
> Given a linear model:
>
> ```{r, eval=FALSE}
> mod <- aov(pop ~ lifeExp, data=gapminder)
> ```
>
> Extract the residual degrees of freedom (hint: `attributes()` will help you)
>

## Data frames

Remember the data frames are lists underneath the hood, so similar rules
apply. However they are also two dimensional objects:

`[` with one argument will act the same was as for lists, where each list
element corresponds to a column. The resulting object will be a data frame:

```{r}
head(gapminder[3])
```

Similarly, `[[` will act to extract *a single column*:

```{r}
head(gapminder[["lifeExp"]])
```

And `$` provides a convenient shorthand to extract columns by name:

```{r}
head(gapminder$year)
```

With two arguments, `[` behaves the same way as for matrices:

```{r}
gapminder[1:3,]
```

If we subset a single row, the result will be a data frame (because
the elements are mixed types):

```{r}
gapminder[3,]
```

But for a single column the result will be a vector (this can
be changed with the third argument, `drop = FALSE`).

> ## Challenge 7 {.challenge}
>
> Fix each of the following common data frame subsetting errors:
>
> 1. Extract observations collected for the year 1957
>
> ```{r, eval=FALSE}
> gapminder[gapminder$year = 1957,]
> ```
>
> 2. Extract all columns except 1 through to 4
>
> ```{r, eval=FALSE}
> gapminder[,-1:4]
> ```
>
> 3. Extract the rows where the life expectancy is longer the 80 years
>
> ```{r, eval=FALSE}
> gapminder[gapminder$lifeExp > 80]
> ```
>
> 4. Extract the first row, and the fourth and fifth columns
>   (`lifeExp` and `gdpPercap`).
>
> ```{r, eval=FALSE}
> gapminder[1, 4, 5]
> ```
>
> 5. Advanced: extract rows that contain information for the years 2002
>    and 2007
>
> ```{r, eval=FALSE}
> gapminder[gapminder$year == 2002 | 2007,]
> ```
>

> ## Challenge 8 {.challenge}
>
> 1. Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?
>
>
> 2. Create a new `data.frame` called `gapminder_small` that only contains rows 1 through 9
> and 19 through 23. You can do this in one or two steps.
>

## Challenge solutions

> ## Solution to challenge 1 {.challenge}
>
> Given the following code:
>
> ```{r}
> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
> names(x) <- c('a', 'b', 'c', 'd', 'e')
> print(x)
> ```
>
> 1. Come up with at least 3 different commands that will produce the following output:
>
> ```{r, echo=FALSE}
> x[2:4]
> ```
>
> ```{r, eval=FALSE}
> x[2:4] 
> x[-c(1,5)]
> x[c("b", "c", "d")]
> x[c(2,3,4)]
> ```
>
>


> ## Solution to challenge 2 {.challenge}
>
> Run the following code to define vector `x` as above:
>
> ```{.r}
> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
> names(x) <- c('a', 'b', 'c', 'd', 'e')
> print(x)
> ```
>
> Given this vector `x`, what would you expect the following to do?
>```{.r, eval=FALSE}
> x[-which(names(x) == "g")]
>```
>
> Try out this command and see what you get. Did this match your expectation?
>
> Why did we get this result? (Tip: test out each part of the command on it's own like we just did above - this is a useful debugging strategy)
>
> Which of the following are true:
>
> * A) if there are no `TRUE` values passed to "which", an empty vector is returned
> * B) if there are no `TRUE` values passed to "which", an error message is shown
> * C) `integer()` is an empty vector
> * D) making an empty vector negative produces an "everything" vector
> * E) `x[]` gives the same result as `x[integer()]`
>
> Answer: A and C are correct.
>
> The `which` command returns the index of every `TRUE` value in its input. The `names(x) == "g"` command didn't return any `TRUE` values. Because there were no `TRUE` values passed to the `which` command, it returned an empty vector. Negating this vector with the minus sign didn't change its meaning. Because we used this empty vector to retrieve values from `x`, it produced an empty numeric vector. It was a `named numeric` empty vector because the vector type of x is "named numeric" since we assigned names to the values (try `str(x)` ).



> ## Solution to challenge 4 {.challenge}
>
> Given the following code:
>
> ```{r}
> m <- matrix(1:18, nrow=3, ncol=6)
> print(m)
> ```
>
> 1. Which of the following commands will extract the values 11 and 14?
>
> A. `m[2,4,2,5]`
>
> B. `m[2:5]`
>
> C. `m[4:5,2]`
>
> D. `m[2,c(4,5)]`
>
> Answer: D

> ## Solution to challenge 5 {.challenge}
> Given the following list:
>
> ```{r}
> xlist <- list(a = "Software Carpentry", b = 1:10, data = head(iris))
> ```
>
> Using your knowledge of both list and vector subsetting, extract the number 2 from xlist. 
> Hint: the number 2 is contained within the "b" item in the list.
>
> ```{r, eval=FALSE}
> xlist$b[2]
> xlist[[2]][2]
> xlist[["b"]][2]
> ```


> ## Solution to challenge 6 {.challenge}
> Given a linear model:
>
> ```{r}
> mod <- aov(pop ~ lifeExp, data=gapminder)
> ```
>
> Extract the residual degrees of freedom (hint: `attributes()` will help you)
>
> ```{r, eval=FALSE}
> attributes(mod) ## `df.residual` is one of the names of `mod`
> mod$df.residual
> ```


> ## Solution to challenge 7 {.challenge}
>
> Fix each of the following common data frame subsetting errors:
>
> 1. Extract observations collected for the year 1957
>
> ```{r, eval=FALSE}
> # gapminder[gapminder$year = 1957,]
> gapminder[gapminder$year == 1957,]
> ```
>
> 2. Extract all columns except 1 through to 4
>
> ```{r, eval=FALSE}
> # gapminder[,-1:4]
> gapminder[,-c(1:4)]
> ```
>
> 3. Extract the rows where the life expectancy is longer the 80 years
>
> ```{r, eval=FALSE}
> # gapminder[gapminder$lifeExp > 80]
> gapminder[gapminder$lifeExp > 80,]
> ```
>
> 4. Extract the first row, and the fourth and fifth columns
>   (`lifeExp` and `gdpPercap`).
>
> ```{r, eval=FALSE}
> # gapminder[1, 4, 5]
> gapminder[1, c(4, 5)]
> ```
>
> 5. Advanced: extract rows that contain information for the years 2002
>    and 2007
>
> ```{r, eval=FALSE}
> # gapminder[gapminder$year == 2002 | 2007,]
> gapminder[gapminder$year == 2002 | gapminder$year == 2007,]
> gapminder[gapminder$year %in% c(2002, 2007),]
> ```
>

> ## Solution to challenge 8 {.challenge}
>
> 1. Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?
>
> Answer: `gapminder` is a data.frame so needs to be subsetted on two dimensions. `gapminder[1:20, ]` subsets the data to give the first 20 rows and all columns.
>
> 2. Create a new `data.frame` called `gapminder_small` that only contains rows 1 through 9
> and 19 through 23. You can do this in one or two steps.
>
> ```{r}
> gapminder_small <- gapminder[c(1:9, 19:23),]
> ```
>
