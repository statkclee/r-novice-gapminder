<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: 재현가능한 과학적 분석을 위한 R</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">재현가능한 과학적 분석을 위한 R</h1></a>
          <h2 class="subtitle">데이터 부분집합</h2>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="학습-목표"><span class="glyphicon glyphicon-certificate"></span>학습 목표</h2>
</div>
<div class="panel-body">
<ul>
<li>벡터, 요인, 행렬, 리스트, 데이터프레임 부분집합을 뽑아낼 수 있다.</li>
<li>개별, 다수 요소를 다음 기준으로 뽑아낼 수 있다:
<ul>
<li>색인</li>
<li>명칭</li>
<li>비교 연산을 사용</li>
</ul></li>
<li>다양한 자료구조로부터 요소를 건너뛰거나 제거할 수 있다.</li>
</ul>
</div>
</section>
<p>R에는 강력한 부분집합 연산자를 다수 구비되어 있다. 이를 완전히 익히게 되면 어떤 유형의 데이터셋에 대해서도 복잡한 연산을 수월하게 수행할 수 있게 된다.</p>
<p>어떤 유형의 객체에서 부분집합을 뽑아낼 수 있는 방식은 6가지가 있다. 다른 자료구조에 대한 부분집합을 뽑아내는 연산자는 3가지가 있다.</p>
<p>R의 핵심으로 가장 많은 일은 하는 것부터 시작해본다: 원자 벡터(atomic vector)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
x</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p>이제 작업할 준비가 마루타 벡터를 생성했다. 해당 벡터 내용물을 손에 넣는 방식은 무엇인가?</p>
<h2 id="색인을-사용한-요소-접근">색인을 사용한 요소 접근</h2>
<p>벡터 요소를 추출하는데, 대응되는 색인을 부여하는데, 1부터 시작된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">1</span>]</code></pre></div>
<pre class="output"><code>  a 
5.4 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">4</span>]</code></pre></div>
<pre class="output"><code>  d 
4.8 
</code></pre>
<p>꺾쇠 괄호 연산자는 다른 어떤 함수와 비슷한다. 원자 벡터(그리과 행렬)에 대해, “n번째 요소를 뽑아낸다”라는 의미다.</p>
<p>한번에 다수 요소를 뽑아낼 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>)]</code></pre></div>
<pre class="output"><code>  a   c 
5.4 7.1 
</code></pre>
<p>혹은, 벡터 슬라이스로 뽑아낼 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">1</span>:<span class="dv">4</span>]</code></pre></div>
<pre class="output"><code>  a   b   c   d 
5.4 6.2 7.1 4.8 
</code></pre>
<p><code>:</code> 연산자는 왼쪽 요소부터 우측 요소까지 연속된 숫자를 생성한다. 예를 들어, <code>x[1:4]</code> 은 <code>x[c(1,2,3,4)]</code>와 동등하다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>)]</code></pre></div>
<pre class="output"><code>  a   a   c 
5.4 5.4 7.1 
</code></pre>
<p>벡터를 벗어난 숫자를 뽑아내려고 하면, R은 결측값을 반환한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">6</span>]</code></pre></div>
<pre class="output"><code>&lt;NA&gt; 
  NA 
</code></pre>
<p>길이 1을 갖는 벡터로 <code>NA</code>가 담겨있고, 명칭도 <code>NA</code>다.</p>
<p>0번째 요소를 뽑아내려고 하면, 공벡터가 반환된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">0</span>]</code></pre></div>
<pre class="output"><code>named numeric(0)
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="r에서-벡터-번호매기는-것은-1에서-시작"><span class="glyphicon glyphicon-pushpin"></span>R에서 벡터 번호매기는 것은 1에서 시작</h2>
</div>
<div class="panel-body">
<p>대다수 프로그래밍 언어(C와 파이썬)에서, 벡터 첫번째 요소는 색인 0을 갖는다. R에서, 첫번째 요소는 1이다.</p>
</div>
</aside>
<h2 id="요소-건너뛰고-제거하기">요소 건너뛰고 제거하기</h2>
<p>벡터 색인으로 음수를 사용하면, R은 명세된 숫자를 제외한 모든 요소를 반환한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="dv">2</span>]</code></pre></div>
<pre class="output"><code>  a   c   d   e 
5.4 7.1 4.8 7.5 
</code></pre>
<p>다수 요소를 건너뛸 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">5</span>)]  <span class="co"># 혹은 x[-c(1,5)]</span></code></pre></div>
<pre class="output"><code>  b   c   d 
6.2 7.1 4.8 
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-연산작업-순서"><span class="glyphicon glyphicon-pushpin"></span>Tip: 연산작업 순서</h2>
</div>
<div class="panel-body">
<p>초보자가 범하는 일반적인 실수는 벡터 슬라이스 건너뛰기 연산을 시도할 때 일어나다. 먼저 사람 대부분은 순열을 다음과 같이 부정연산을 통해 변경하려 한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="dv">1</span>:<span class="dv">3</span>]</code></pre></div>
<pre class="error"><code>Error in x[-1:3]: only 0&#39;s may be mixed with negative subscripts
</code></pre>
<p>다소 암호스런 오류가 제시된다:</p>
<p>하지만, 연산작업 우선수위를 기억해보자. <code>:</code> 연산자는 사실 함수다. 그래서, 일어난 상황은 -1을 첫번째 인자로 받고, 두번째 인자로 3을 받아서, 연속된 숫자를 생성해낸다: <code>c(-1, 0, 1, 2, 3)</code>.</p>
<p>올바른 해법은 함수 호출을 괄호로 감싸는 것이다. <code>-</code> 연산자가 결과를 도출한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-(<span class="dv">1</span>:<span class="dv">3</span>)]</code></pre></div>
<pre class="output"><code>  d   e 
4.8 7.5 
</code></pre>
</div>
</aside>
<p>벡터에서 요소를 제거하려면, 결과를 다시 벡터에 대입할 필요가 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>x[-<span class="dv">4</span>]
x</code></pre></div>
<pre class="output"><code>  a   b   c   e 
5.4 6.2 7.1 7.5 
</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전-과제-1"><span class="glyphicon glyphicon-pencil"></span>도전 과제 1</h2>
</div>
<div class="panel-body">
<p>다음과 같이 코드가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<ol style="list-style-type: decimal">
<li>다음 출력과를 산출하는 적어도 서로 다른 명령어를 제시한다:</li>
</ol>
<pre class="output"><code>  b   c   d 
6.2 7.1 4.8 
</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>작업결과를 옆 사람과 비교한다. 서로 다른 전략을 취했나요?</li>
</ol>
</div>
</section>
<h2 id="명칭으로-부분집합-뽑아내기">명칭으로 부분집합 뽑아내기</h2>
<p>색인 대신에 명칭을 사용해서, 요소를 뽑아낼 수 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>)]</code></pre></div>
<pre class="output"><code>  a   c 
5.4 7.1 
</code></pre>
<p>명칭을 사용한 것이 객체에 대한 부분집합을 뽑아내는 훨씬 더 신뢰성 있는 방식이다: 다양한 요소 위치는 부분집합을 뽑아내는 연산자를 연결해서 적용할 때 종종 변경되지만, 명칭은 항상 동일하게 남게 마련이다!</p>
<p>불행하게도, 그다지 수월하게 요소를 건너뛰거나 제거할 수는 없다.</p>
<p>요소 하나를 건너뛰거나 제거하려면:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;a&quot;</span>)]</code></pre></div>
<pre class="output"><code>  b   c   d   e 
6.2 7.1 4.8 7.5 
</code></pre>
<p><code>which</code> 함수는 함수 인자의 모든 <code>TRUE</code> 요소에 대한 색인을 반환한다. 함수에 전달되기 전에 표현식이 평가됨을 기억한다. 내부를 파고들어, 어떤 일이 진행되는지 명확히 알아보자.</p>
<p>다음이 가장 먼저 진행된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) ==<span class="st"> &quot;a&quot;</span></code></pre></div>
<pre class="output"><code>[1]  TRUE FALSE FALSE FALSE FALSE
</code></pre>
<p>조건 연산자는 <code>x</code> 벡터에 대한 모든 명칭에 적용된다. 첫번째 명칭만 “a” 라서, 해당 요소만 참(TRUE)이 된다.</p>
<p>그리고 나면, <code>which</code>가 이를 색인으로 변환한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;a&quot;</span>)</code></pre></div>
<pre class="output"><code>[1] 1
</code></pre>
<p>첫번째 요소만 <code>참(TRUE)</code>이라서, <code>which</code>는 1을 반환한다. 이제 색인을 갖게 되서, 건너뛰는 연산이 동작한다. 왜냐하면 음수 색인이기 때문이다!</p>
<p>명칭을 갖는 다수 색인을 건너뛰는 것도 유사하다. 하지만, 다른 비교 연산자를 사용한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>))]</code></pre></div>
<pre class="output"><code>  b   d   e 
6.2 4.8 7.5 
</code></pre>
<p><code>%in%</code> 비교연산자는 좌측 인자(이번 경우에, <code>x</code> 명칭)에 대한 각 요소를 훑는다. 그리고 나서, “해당 요소가 두번째 인자에 나타나는가?”라고 질의한다.</p>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-2"><span class="glyphicon glyphicon-pencil"></span>도전과제 2</h2>
</div>
<div class="panel-body">
<p>Run the following code to define vector <code>x</code> as above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p>Given this vector <code>x</code>, what would you expect the following to do?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;g&quot;</span>)]</code></pre></div>
<p>Try out this command and see what you get. Did this match your expectation? Why did we get this result? (Tip: test out each part of the command on it’s own like we just did above - this is a useful debugging strategy)</p>
<p>Which of the following are true:</p>
<ul>
<li><ol style="list-style-type: upper-alpha">
<li>if there are no <code>TRUE</code> values passed to <code>which</code>, an empty vector is returned</li>
</ol></li>
<li><ol start="2" style="list-style-type: upper-alpha">
<li>if there are no <code>TRUE</code> values passed to <code>which</code>, an error message is shown</li>
</ol></li>
<li><ol start="3" style="list-style-type: upper-alpha">
<li><code>integer()</code> is an empty vector</li>
</ol></li>
<li><ol start="4" style="list-style-type: upper-alpha">
<li>making an empty vector negative produces an “everything” vector</li>
</ol></li>
<li><ol start="5" style="list-style-type: upper-alpha">
<li><code>x[]</code> gives the same result as <code>x[integer()]</code></li>
</ol></li>
</ul>
</div>
</section>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-유일무이하지-않은-명칭"><span class="glyphicon glyphicon-pushpin"></span>Tip: 유일무이하지 않은 명칭</h2>
</div>
<div class="panel-body">
<p>벡터에 요소 다수가 동일 명칭을 갖을 수 있음에 유의해야만 된다. (데이터프레임에서, 칼럼이 동일한 명칭을 갖을 수 있다 — R이 이런 점을 회피하려고 하지만 — 하지만, 행 명칭은 유일무이해야 된다.) 다음 예제를 고려해보자:</p>
</div>
</aside>
<blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">3</span>
x</code></pre></div>
<pre class="output"><code>[1] 1 2 3
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>)  
x</code></pre></div>
<pre class="output"><code>a a a 
1 2 3 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="st">&#39;a&#39;</span>]  <span class="co"># 첫번째 값만 반환한다.</span></code></pre></div>
<pre class="output"><code>a 
1 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &#39;a&#39;</span>)]  <span class="co"># 세가지 값 모두 반환한다.</span></code></pre></div>
<pre class="output"><code>a a a 
1 2 3 
</code></pre>
</blockquote>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-연산자에-대한-도움말-얻기"><span class="glyphicon glyphicon-pushpin"></span>Tip: 연산자에 대한 도움말 얻기</h2>
</div>
<div class="panel-body">
<p>인용부호 내부에 찾고자 하는 연산자를 감싸서 도움말을 검색할 수 있다: <code>help(&quot;%in%&quot;)</code> 혹은 <code>?&quot;%in%&quot;</code>.</p>
</div>
</aside>
<p>그러면, 이전처럼 <code>==</code> 연산자는 왜 사용할 수 없을까? 매우 좋은 질문이다.</p>
<p>비교에 해당되는 항목만 살펴보자:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) ==<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>)</code></pre></div>
<pre class="error"><code>Warning in names(x) == c(&quot;a&quot;, &quot;c&quot;): 두 객체의 길이가 서로 배수관계에 있지
않습니다
</code></pre>
<pre class="output"><code>[1]  TRUE FALSE  TRUE
</code></pre>
<p>분명히, “c”는 <code>x</code> 요소명칭 중에 존재한다. 그런데, 왜 동작을 하지 않을까? <code>==</code>은 <code>%in%</code> 과는 다소 다른방식으로 동작한다. <code>==</code>은 좌측 인자 요소 각각을 대응되는 우측 요소 각각과 비교한다.</p>
<p><code>==</code> 연산자를 모사한 것이 다음에 나와 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;e&quot;</span>)  <span class="co"># x 명칭</span>
   |<span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="co"># ==으로 요소들을 비교한다.</span>
<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>)</code></pre></div>
<p>한 벡터가 다른 벡터보다 작은 경우, 해당 벡터는 <em>재사용</em>된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;e&quot;</span>)  <span class="co"># x 명칭</span>
   |<span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="co"># ==으로 요소들을 비교한다.</span>
<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>)</code></pre></div>
<p>이런 경우, R이 단순히 <code>c(&quot;a&quot;, &quot;c&quot;)</code>을 두번 반복한다. 더 긴 벡터가 더 짧은 벡터의 배수가 아닌 경우, R은 경고 메시지도 출력한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) ==<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;e&#39;</span>)</code></pre></div>
<pre class="output"><code>[1]  TRUE FALSE FALSE
</code></pre>
<p><code>==</code> 와 <code>%in%</code> 차이점을 숙지하는 것이 중요한데, 이유는 탐지가 어렵고 미묘한 버그가 스며들 수 있기 때문이다!</p>
<h2 id="논리-연산자를-통한-부분집합-뽑아내기">논리 연산자를 통한 부분집합 뽑아내기</h2>
<p>더 단순하게는 논리 연산자로 부분집합을 뽑아낼 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>)]</code></pre></div>
<pre class="output"><code>a a 
1 2 
</code></pre>
<p>이번 경우, 논리 벡터는 부분집합을 뽑아내는 벡터 길이만큼 재사용됨에 주목한다!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]</code></pre></div>
<pre class="output"><code>a a 
1 3 
</code></pre>
<p>비교 연산자는 논리벡터로 평가되기 때문에, 간결하게 벡터 부분집합을 뽑아내는데 사용할 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[x &gt;<span class="st"> </span><span class="dv">7</span>]</code></pre></div>
<pre class="output"><code>named integer(0)
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-논리-연산자-연쇄-체인-구성"><span class="glyphicon glyphicon-pushpin"></span>Tip: 논리 연산자 연쇄 체인 구성</h2>
</div>
<div class="panel-body">
<p>다수 조건을 조합하고자 하는 상황이 많이 있다. 이런 작업을 수행하는데 필요한 논리 연산자가 R에서 지원된다:</p>
<ul>
<li><code>|</code> 논리 OR: 왼쪽 오른쪽 어느 한쪽이 <code>TRUE</code>면, <code>TRUE</code>를 반환한다.</li>
<li><code>&amp;</code> 논리 AND: 왼쪽 오른쪽 모두가 <code>TRUE</code>면, <code>TRUE</code>를 반환한다.</li>
<li><code>!</code> 논리 NOT: <code>TRUE</code>는 <code>FALSE</code>로, <code>FALSE</code>는 <code>TRUE</code>로 전환한다.</li>
<li><code>&amp;&amp;</code> , <code>||</code> 은 두 벡터의 개별 요소를 비교한다. 재활용 규칙은 이곳도 적용된다.</li>
</ul>
</div>
</aside>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-3"><span class="glyphicon glyphicon-pencil"></span>도전과제 3</h2>
</div>
<div class="panel-body">
<p>다음 코드가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p><code>x</code> 벡터에서 4보다 크고 7보다 적은 값을 부분집합으로 뽑아내는 명령어를 작성한다.</p>
</div>
</section>
<h2 id="특수값-처리하기">특수값 처리하기</h2>
<p>어느 지점에 다다르면, R 함수에 처리할 수 없는 결측값, 무한값, 정의되지 않는 값을 갖는 데이터와 마주하게 된다.</p>
<p>이런 유형의 데이터를 필터링하는데 사용되는 특수 함수가 있다:</p>
<ul>
<li><code>is.na</code>는 벡터, 행렬, 데이터프레임에 포함된 <code>NA</code> 위치를 반환한다.</li>
<li>마찬가지로, <code>is.nan</code> 와 <code>is.infinite</code> 함수도 <code>NaN</code> 와 <code>Inf</code> 값에 대한 동일한 작업을 수행한다.</li>
<li><code>is.finite</code> 함수는 <code>NA</code>, <code>NaN</code>, <code>Inf</code> 값을 포함하지 않는 벡터, 행렬, 데이터프레임에 대한 모든 위치정보를 반환한다.</li>
<li><code>na.omit</code>는 벡터에서 모든 결측값을 필터링해서 제외시키다.</li>
</ul>
<h2 id="요인-부분집합으로-뽑아내기">요인 부분집합으로 뽑아내기</h2>
<p>지금까지 벡터 부분집합을 뽑아내는 다양한 방식을 탐색했다. 다른 자료구조에 대한 부분집합은 어떻게 뽑아낼 수 있을까?</p>
<p>요인 부분집합 뽑아내기는 벡터 부분집합 뽑아내기와 동일한 방식으로 동작한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>))
f[f ==<span class="st"> &quot;a&quot;</span>]</code></pre></div>
<pre class="output"><code>[1] a a
Levels: a b c d
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f[f %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)]</code></pre></div>
<pre class="output"><code>[1] b c c
Levels: a b c d
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f[<span class="dv">1</span>:<span class="dv">3</span>]</code></pre></div>
<pre class="output"><code>[1] a a b
Levels: a b c d
</code></pre>
<p>중요한 주의점 하나는 건너뛰는 요소가 설사 해당 범주가 요인으로 존재하지 않더라도, 수준(level)을 제거하지 않는다는 점이다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f[-<span class="dv">3</span>]</code></pre></div>
<pre class="output"><code>[1] a a c c d
Levels: a b c d
</code></pre>
<h2 id="행렬-부분집합-뽑아내기">행렬 부분집합 뽑아내기</h2>
<p>Matrices are also subsetted using the <code>[</code> function. In this case it takes two arguments: the first applying to the rows, the second to its columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">6</span>*<span class="dv">4</span>), <span class="dt">ncol=</span><span class="dv">4</span>, <span class="dt">nrow=</span><span class="dv">6</span>)
m[<span class="dv">3</span>:<span class="dv">4</span>, <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>)]</code></pre></div>
<pre class="output"><code>            [,1]       [,2]
[1,]  1.12493092 -0.8356286
[2,] -0.04493361  1.5952808
</code></pre>
<p>You can leave the first or second arguments blank to retrieve all the rows or columns respectively:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[, <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>)]</code></pre></div>
<pre class="output"><code>            [,1]        [,2]
[1,] -0.62124058  0.82122120
[2,] -2.21469989  0.59390132
[3,]  1.12493092  0.91897737
[4,] -0.04493361  0.78213630
[5,] -0.01619026  0.07456498
[6,]  0.94383621 -1.98935170
</code></pre>
<p>If we only access one row or column, R will automatically convert the result to a vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[<span class="dv">3</span>,]</code></pre></div>
<pre class="output"><code>[1] -0.8356286  0.5757814  1.1249309  0.9189774
</code></pre>
<p>If you want to keep the output as a matrix, you need to specify a <em>third</em> argument; <code>drop = FALSE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[<span class="dv">3</span>, , drop=<span class="ot">FALSE</span>]</code></pre></div>
<pre class="output"><code>           [,1]      [,2]     [,3]      [,4]
[1,] -0.8356286 0.5757814 1.124931 0.9189774
</code></pre>
<p>Unlike vectors, if we try to access a row or column outside of the matrix, R will throw an error:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[, <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">6</span>)]</code></pre></div>
<pre class="error"><code>Error in m[, c(3, 6)]: 첨자의 허용 범위를 벗어났습니다
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-higher-dimensional-arrays"><span class="glyphicon glyphicon-pushpin"></span>Tip: Higher dimensional arrays</h2>
</div>
<div class="panel-body">
<p>when dealing with multi-dimensional arrays, each argument to <code>[</code> corresponds to a dimension. For example, a 3D array, the first three arguments correspond to the rows, columns, and depth dimension.</p>
</div>
</aside>
<p>Because matrices are really just vectors underneath the hood, we can also subset using only one argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[<span class="dv">5</span>]</code></pre></div>
<pre class="output"><code>[1] 0.3295078
</code></pre>
<p>This usually isn’t useful. However it is useful to note that matrices are laid out in <em>column-major format</em> by default. That is the elements of the vector are arranged column-wise:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">6</span>, <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">ncol=</span><span class="dv">3</span>)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
</code></pre>
<p>If you wish to populate the matrix by row, use <code>byrow=TRUE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">6</span>, <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">ncol=</span><span class="dv">3</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
</code></pre>
<p>Matrices can also be subsetted using their rownames and column names instead of their row and column indices.</p>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="challenge-4"><span class="glyphicon glyphicon-pencil"></span>Challenge 4</h2>
</div>
<div class="panel-body">
<p>Given the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">18</span>, <span class="dt">nrow=</span><span class="dv">3</span>, <span class="dt">ncol=</span><span class="dv">6</span>)
<span class="kw">print</span>(m)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    4    7   10   13   16
[2,]    2    5    8   11   14   17
[3,]    3    6    9   12   15   18
</code></pre>
<ol style="list-style-type: decimal">
<li>Which of the following commands will extract the values 11 and 14?</li>
</ol>
<p>A. <code>m[2,4,2,5]</code></p>
<p>B. <code>m[2:5]</code></p>
<p>C. <code>m[4:5,2]</code></p>
<p>D. <code>m[2,c(4,5)]</code></p>
</div>
</section>
<h2 id="list-subsetting">List subsetting</h2>
<p>Now we’ll introduce some new subsetting operators. There are three functions used to subset lists. <code>[</code>, as we’ve seen for atomic vectors and matrices, as well as <code>[[</code> and <code>$</code>.</p>
<p>Using <code>[</code> will always return a list. If you want to <em>subset</em> a list, but not <em>extract</em> an element, then you will likely use <code>[</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="st">&quot;Software Carpentry&quot;</span>, <span class="dt">b =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">data =</span> <span class="kw">head</span>(iris))
xlist[<span class="dv">1</span>]</code></pre></div>
<pre class="output"><code>$a
[1] &quot;Software Carpentry&quot;
</code></pre>
<p>This returns a <em>list with one element</em>.</p>
<p>We can subset elements of a list exactly the same was as atomic vectors using <code>[</code>. Comparison operations however won’t work as they’re not recursive, they will try to condition on the data structures in each element of the list, not the individual elements within those data structures.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[<span class="dv">1</span>:<span class="dv">2</span>]</code></pre></div>
<pre class="output"><code>$a
[1] &quot;Software Carpentry&quot;

$b
 [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>
<p>To extract individual elements of a list, you need to use the double-square bracket function: <code>[[</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[<span class="dv">1</span>]]</code></pre></div>
<pre class="output"><code>[1] &quot;Software Carpentry&quot;
</code></pre>
<p>Notice that now the result is a vector, not a list.</p>
<p>You can’t extract more than one element at once:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[<span class="dv">1</span>:<span class="dv">2</span>]]</code></pre></div>
<pre class="error"><code>Error in xlist[[1:2]]: 첨자의 허용 범위를 벗어났습니다
</code></pre>
<p>Nor use it to skip elements:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[-<span class="dv">1</span>]]</code></pre></div>
<pre class="error"><code>Error in xlist[[-1]]: 한 개 이상의 구성요소 선택을 시도합니다
</code></pre>
<p>But you can use names to both subset and extract elements:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[<span class="st">&quot;a&quot;</span>]]</code></pre></div>
<pre class="output"><code>[1] &quot;Software Carpentry&quot;
</code></pre>
<p>The <code>$</code> function is a shorthand way for extracting elements by name:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist$data</code></pre></div>
<pre class="output"><code>  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="challenge-5"><span class="glyphicon glyphicon-pencil"></span>Challenge 5</h2>
</div>
<div class="panel-body">
<p>Given the following list:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="st">&quot;Software Carpentry&quot;</span>, <span class="dt">b =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">data =</span> <span class="kw">head</span>(iris))</code></pre></div>
<p>Using your knowledge of both list and vector subsetting, extract the number 2 from xlist. Hint: the number 2 is contained within the “b” item in the list.</p>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="challenge-6"><span class="glyphicon glyphicon-pencil"></span>Challenge 6</h2>
</div>
<div class="panel-body">
<p>Given a linear model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">aov</span>(pop ~<span class="st"> </span>lifeExp, <span class="dt">data=</span>gapminder)</code></pre></div>
<p>Extract the residual degrees of freedom (hint: <code>attributes()</code> will help you)</p>
</div>
</section>
<h2 id="data-frames">Data frames</h2>
<p>Remember the data frames are lists underneath the hood, so similar rules apply. However they are also two dimensional objects:</p>
<p><code>[</code> with one argument will act the same was as for lists, where each list element corresponds to a column. The resulting object will be a data frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(gapminder[<span class="dv">3</span>])</code></pre></div>
<pre class="output"><code>       pop
1  8425333
2  9240934
3 10267083
4 11537966
5 13079460
6 14880372
</code></pre>
<p>Similarly, <code>[[</code> will act to extract <em>a single column</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(gapminder[[<span class="st">&quot;lifeExp&quot;</span>]])</code></pre></div>
<pre class="output"><code>[1] 28.801 30.332 31.997 34.020 36.088 38.438
</code></pre>
<p>And <code>$</code> provides a convenient shorthand to extract columns by name:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(gapminder$year)</code></pre></div>
<pre class="output"><code>[1] 1952 1957 1962 1967 1972 1977
</code></pre>
<p>With two arguments, <code>[</code> behaves the same way as for matrices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[<span class="dv">1</span>:<span class="dv">3</span>,]</code></pre></div>
<pre class="output"><code>      country year      pop continent lifeExp gdpPercap
1 Afghanistan 1952  8425333      Asia  28.801  779.4453
2 Afghanistan 1957  9240934      Asia  30.332  820.8530
3 Afghanistan 1962 10267083      Asia  31.997  853.1007
</code></pre>
<p>If we subset a single row, the result will be a data frame (because the elements are mixed types):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[<span class="dv">3</span>,]</code></pre></div>
<pre class="output"><code>      country year      pop continent lifeExp gdpPercap
3 Afghanistan 1962 10267083      Asia  31.997  853.1007
</code></pre>
<p>But for a single column the result will be a vector (this can be changed with the third argument, <code>drop = FALSE</code>).</p>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="challenge-7"><span class="glyphicon glyphicon-pencil"></span>Challenge 7</h2>
</div>
<div class="panel-body">
<p>Fix each of the following common data frame subsetting errors:</p>
<ol style="list-style-type: decimal">
<li>Extract observations collected for the year 1957</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[gapminder$year =<span class="st"> </span><span class="dv">1957</span>,]</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Extract all columns except 1 through to 4</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[,-<span class="dv">1</span>:<span class="dv">4</span>]</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Extract the rows where the life expectancy is longer the 80 years</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[gapminder$lifeExp &gt;<span class="st"> </span><span class="dv">80</span>]</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>Extract the first row, and the fourth and fifth columns (<code>lifeExp</code> and <code>gdpPercap</code>).</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>]</code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Advanced: extract rows that contain information for the years 2002 and 2007</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[gapminder$year ==<span class="st"> </span><span class="dv">2002</span> |<span class="st"> </span><span class="dv">2007</span>,]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="challenge-8"><span class="glyphicon glyphicon-pencil"></span>Challenge 8</h2>
</div>
<div class="panel-body">
<ol style="list-style-type: decimal">
<li><p>Why does <code>gapminder[1:20]</code> return an error? How does it differ from <code>gapminder[1:20, ]</code>?</p></li>
<li><p>Create a new <code>data.frame</code> called <code>gapminder_small</code> that only contains rows 1 through 9 and 19 through 23. You can do this in one or two steps.</p></li>
</ol>
</div>
</section>
<h2 id="challenge-solutions">Challenge solutions</h2>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="solution-to-challenge-1"><span class="glyphicon glyphicon-pencil"></span>Solution to challenge 1</h2>
</div>
<div class="panel-body">
<p>Given the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<ol style="list-style-type: decimal">
<li>Come up with at least 3 different commands that will produce the following output:</li>
</ol>
<pre class="output"><code>  b   c   d 
6.2 7.1 4.8 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">2</span>:<span class="dv">4</span>] 
x[-<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">5</span>)]
x[<span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>)]
x[<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="solution-to-challenge-2"><span class="glyphicon glyphicon-pencil"></span>Solution to challenge 2</h2>
</div>
<div class="panel-body">
<p>Run the following code to define vector <code>x</code> as above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p>Given this vector <code>x</code>, what would you expect the following to do?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;g&quot;</span>)]</code></pre></div>
<p>Try out this command and see what you get. Did this match your expectation?</p>
<p>Why did we get this result? (Tip: test out each part of the command on it’s own like we just did above - this is a useful debugging strategy)</p>
<p>Which of the following are true:</p>
<ul>
<li><ol style="list-style-type: upper-alpha">
<li>if there are no <code>TRUE</code> values passed to “which”, an empty vector is returned</li>
</ol></li>
<li><ol start="2" style="list-style-type: upper-alpha">
<li>if there are no <code>TRUE</code> values passed to “which”, an error message is shown</li>
</ol></li>
<li><ol start="3" style="list-style-type: upper-alpha">
<li><code>integer()</code> is an empty vector</li>
</ol></li>
<li><ol start="4" style="list-style-type: upper-alpha">
<li>making an empty vector negative produces an “everything” vector</li>
</ol></li>
<li><ol start="5" style="list-style-type: upper-alpha">
<li><code>x[]</code> gives the same result as <code>x[integer()]</code></li>
</ol></li>
</ul>
<p>Answer: A and C are correct.</p>
<p>The <code>which</code> command returns the index of every <code>TRUE</code> value in its input. The <code>names(x) == &quot;g&quot;</code> command didn’t return any <code>TRUE</code> values. Because there were no <code>TRUE</code> values passed to the <code>which</code> command, it returned an empty vector. Negating this vector with the minus sign didn’t change its meaning. Because we used this empty vector to retrieve values from <code>x</code>, it produced an empty numeric vector. It was a <code>named numeric</code> empty vector because the vector type of x is “named numeric” since we assigned names to the values (try <code>str(x)</code> ).</p>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="solution-to-challenge-4"><span class="glyphicon glyphicon-pencil"></span>Solution to challenge 4</h2>
</div>
<div class="panel-body">
<p>Given the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">18</span>, <span class="dt">nrow=</span><span class="dv">3</span>, <span class="dt">ncol=</span><span class="dv">6</span>)
<span class="kw">print</span>(m)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    4    7   10   13   16
[2,]    2    5    8   11   14   17
[3,]    3    6    9   12   15   18
</code></pre>
<ol style="list-style-type: decimal">
<li>Which of the following commands will extract the values 11 and 14?</li>
</ol>
<p>A. <code>m[2,4,2,5]</code></p>
<p>B. <code>m[2:5]</code></p>
<p>C. <code>m[4:5,2]</code></p>
<p>D. <code>m[2,c(4,5)]</code></p>
<p>Answer: D</p>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="solution-to-challenge-5"><span class="glyphicon glyphicon-pencil"></span>Solution to challenge 5</h2>
</div>
<div class="panel-body">
<p>Given the following list:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="st">&quot;Software Carpentry&quot;</span>, <span class="dt">b =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">data =</span> <span class="kw">head</span>(iris))</code></pre></div>
<p>Using your knowledge of both list and vector subsetting, extract the number 2 from xlist. Hint: the number 2 is contained within the “b” item in the list.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist$b[<span class="dv">2</span>]
xlist[[<span class="dv">2</span>]][<span class="dv">2</span>]
xlist[[<span class="st">&quot;b&quot;</span>]][<span class="dv">2</span>]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="solution-to-challenge-6"><span class="glyphicon glyphicon-pencil"></span>Solution to challenge 6</h2>
</div>
<div class="panel-body">
<p>Given a linear model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">aov</span>(pop ~<span class="st"> </span>lifeExp, <span class="dt">data=</span>gapminder)</code></pre></div>
<p>Extract the residual degrees of freedom (hint: <code>attributes()</code> will help you)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attributes</span>(mod) ## `df.residual` is one of the names of `mod`
mod$df.residual</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="solution-to-challenge-7"><span class="glyphicon glyphicon-pencil"></span>Solution to challenge 7</h2>
</div>
<div class="panel-body">
<p>Fix each of the following common data frame subsetting errors:</p>
<ol style="list-style-type: decimal">
<li>Extract observations collected for the year 1957</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[gapminder$year = 1957,]</span>
gapminder[gapminder$year ==<span class="st"> </span><span class="dv">1957</span>,]</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Extract all columns except 1 through to 4</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[,-1:4]</span>
gapminder[,-<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">4</span>)]</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Extract the rows where the life expectancy is longer the 80 years</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[gapminder$lifeExp &gt; 80]</span>
gapminder[gapminder$lifeExp &gt;<span class="st"> </span><span class="dv">80</span>,]</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>Extract the first row, and the fourth and fifth columns (<code>lifeExp</code> and <code>gdpPercap</code>).</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[1, 4, 5]</span>
gapminder[<span class="dv">1</span>, <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">5</span>)]</code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Advanced: extract rows that contain information for the years 2002 and 2007</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[gapminder$year == 2002 | 2007,]</span>
gapminder[gapminder$year ==<span class="st"> </span><span class="dv">2002</span> |<span class="st"> </span>gapminder$year ==<span class="st"> </span><span class="dv">2007</span>,]
gapminder[gapminder$year %in%<span class="st"> </span><span class="kw">c</span>(<span class="dv">2002</span>, <span class="dv">2007</span>),]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="solution-to-challenge-8"><span class="glyphicon glyphicon-pencil"></span>Solution to challenge 8</h2>
</div>
<div class="panel-body">
<ol style="list-style-type: decimal">
<li>Why does <code>gapminder[1:20]</code> return an error? How does it differ from <code>gapminder[1:20, ]</code>?</li>
</ol>
<p>Answer: <code>gapminder</code> is a data.frame so needs to be subsetted on two dimensions. <code>gapminder[1:20, ]</code> subsets the data to give the first 20 rows and all columns.</p>
<ol start="2" style="list-style-type: decimal">
<li>Create a new <code>data.frame</code> called <code>gapminder_small</code> that only contains rows 1 through 9 and 19 through 23. You can do this in one or two steps.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder_small &lt;-<span class="st"> </span>gapminder[<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">9</span>, <span class="dv">19</span>:<span class="dv">23</span>),]</code></pre></div>
</div>
</section>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/lesson-template">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
