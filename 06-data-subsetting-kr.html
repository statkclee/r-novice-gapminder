<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: 재현가능한 과학적 분석을 위한 R</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">재현가능한 과학적 분석을 위한 R</h1></a>
          <h2 class="subtitle">데이터 부분집합</h2>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="학습-목표"><span class="glyphicon glyphicon-certificate"></span>학습 목표</h2>
</div>
<div class="panel-body">
<ul>
<li>벡터, 요인, 행렬, 리스트, 데이터프레임 부분집합을 뽑아낼 수 있다.</li>
<li>개별, 다수 요소를 다음 기준으로 뽑아낼 수 있다:
<ul>
<li>색인</li>
<li>명칭</li>
<li>비교 연산을 사용</li>
</ul></li>
<li>다양한 자료구조로부터 요소를 건너뛰거나 제거할 수 있다.</li>
</ul>
</div>
</section>
<p>R에는 강력한 부분집합 연산자를 다수 구비되어 있다. 이를 완전히 익히게 되면 어떤 유형의 데이터셋에 대해서도 복잡한 연산을 수월하게 수행할 수 있게 된다.</p>
<p>어떤 유형의 객체에서 부분집합을 뽑아낼 수 있는 방식은 6가지가 있다. 다른 자료구조에 대한 부분집합을 뽑아내는 연산자는 3가지가 있다.</p>
<p>R의 핵심으로 가장 많은 일은 하는 것부터 시작해본다: 원자 벡터(atomic vector)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
x</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p>이제 작업할 준비가 마루타 벡터를 생성했다. 해당 벡터 내용물을 손에 넣는 방식은 무엇인가?</p>
<h2 id="색인을-사용한-요소-접근">색인을 사용한 요소 접근</h2>
<p>벡터 요소를 추출하는데, 대응되는 색인을 부여하는데, 1부터 시작된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">1</span>]</code></pre></div>
<pre class="output"><code>  a 
5.4 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">4</span>]</code></pre></div>
<pre class="output"><code>  d 
4.8 
</code></pre>
<p>꺾쇠 괄호 연산자는 다른 어떤 함수와 비슷한다. 원자 벡터(그리과 행렬)에 대해, “n번째 요소를 뽑아낸다”라는 의미다.</p>
<p>한번에 다수 요소를 뽑아낼 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>)]</code></pre></div>
<pre class="output"><code>  a   c 
5.4 7.1 
</code></pre>
<p>혹은, 벡터 슬라이스로 뽑아낼 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">1</span>:<span class="dv">4</span>]</code></pre></div>
<pre class="output"><code>  a   b   c   d 
5.4 6.2 7.1 4.8 
</code></pre>
<p><code>:</code> 연산자는 왼쪽 요소부터 우측 요소까지 연속된 숫자를 생성한다. 예를 들어, <code>x[1:4]</code> 은 <code>x[c(1,2,3,4)]</code>와 동등하다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>)]</code></pre></div>
<pre class="output"><code>  a   a   c 
5.4 5.4 7.1 
</code></pre>
<p>벡터를 벗어난 숫자를 뽑아내려고 하면, R은 결측값을 반환한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">6</span>]</code></pre></div>
<pre class="output"><code>&lt;NA&gt; 
  NA 
</code></pre>
<p>길이 1을 갖는 벡터로 <code>NA</code>가 담겨있고, 명칭도 <code>NA</code>다.</p>
<p>0번째 요소를 뽑아내려고 하면, 공벡터가 반환된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">0</span>]</code></pre></div>
<pre class="output"><code>named numeric(0)
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="r에서-벡터-번호매기는-것은-1에서-시작"><span class="glyphicon glyphicon-pushpin"></span>R에서 벡터 번호매기는 것은 1에서 시작</h2>
</div>
<div class="panel-body">
<p>대다수 프로그래밍 언어(C와 파이썬)에서, 벡터 첫번째 요소는 색인 0을 갖는다. R에서, 첫번째 요소는 1이다.</p>
</div>
</aside>
<h2 id="요소-건너뛰고-제거하기">요소 건너뛰고 제거하기</h2>
<p>벡터 색인으로 음수를 사용하면, R은 명세된 숫자를 제외한 모든 요소를 반환한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="dv">2</span>]</code></pre></div>
<pre class="output"><code>  a   c   d   e 
5.4 7.1 4.8 7.5 
</code></pre>
<p>다수 요소를 건너뛸 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(-<span class="dv">1</span>, -<span class="dv">5</span>)]  <span class="co"># 혹은 x[-c(1,5)]</span></code></pre></div>
<pre class="output"><code>  b   c   d 
6.2 7.1 4.8 
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-연산작업-순서"><span class="glyphicon glyphicon-pushpin"></span>Tip: 연산작업 순서</h2>
</div>
<div class="panel-body">
<p>초보자가 범하는 일반적인 실수는 벡터 슬라이스 건너뛰기 연산을 시도할 때 일어나다. 먼저 사람 대부분은 순열을 다음과 같이 부정연산을 통해 변경하려 한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="dv">1</span>:<span class="dv">3</span>]</code></pre></div>
<pre class="error"><code>Error in x[-1:3]: only 0&#39;s may be mixed with negative subscripts
</code></pre>
<p>다소 암호스런 오류가 제시된다:</p>
<p>하지만, 연산작업 우선수위를 기억해보자. <code>:</code> 연산자는 사실 함수다. 그래서, 일어난 상황은 -1을 첫번째 인자로 받고, 두번째 인자로 3을 받아서, 연속된 숫자를 생성해낸다: <code>c(-1, 0, 1, 2, 3)</code>.</p>
<p>올바른 해법은 함수 호출을 괄호로 감싸는 것이다. <code>-</code> 연산자가 결과를 도출한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-(<span class="dv">1</span>:<span class="dv">3</span>)]</code></pre></div>
<pre class="output"><code>  d   e 
4.8 7.5 
</code></pre>
</div>
</aside>
<p>벡터에서 요소를 제거하려면, 결과를 다시 벡터에 대입할 필요가 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>x[-<span class="dv">4</span>]
x</code></pre></div>
<pre class="output"><code>  a   b   c   e 
5.4 6.2 7.1 7.5 
</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전-과제-1"><span class="glyphicon glyphicon-pencil"></span>도전 과제 1</h2>
</div>
<div class="panel-body">
<p>다음과 같이 코드가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<ol style="list-style-type: decimal">
<li>다음 출력결과를 산출하는 적어도 서로 다른 명령어 3개 제시한다:</li>
</ol>
<pre class="output"><code>  b   c   d 
6.2 7.1 4.8 
</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>작업결과를 옆 사람과 비교한다. 서로 다른 전략을 취했나요?</li>
</ol>
</div>
</section>
<h2 id="명칭으로-부분집합-뽑아내기">명칭으로 부분집합 뽑아내기</h2>
<p>색인 대신에 명칭을 사용해서, 요소를 뽑아낼 수 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>)]</code></pre></div>
<pre class="output"><code>  a   c 
5.4 7.1 
</code></pre>
<p>명칭을 사용한 것이 객체에 대한 부분집합을 뽑아내는 훨씬 더 신뢰성 있는 방식이다: 다양한 요소 위치는 부분집합을 뽑아내는 연산자를 연결해서 적용할 때 종종 변경되지만, 명칭은 항상 동일하게 남게 마련이다!</p>
<p>불행하게도, 그다지 수월하게 요소를 건너뛰거나 제거할 수는 없다.</p>
<p>요소 하나를 건너뛰거나 제거하려면:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;a&quot;</span>)]</code></pre></div>
<pre class="output"><code>  b   c   d   e 
6.2 7.1 4.8 7.5 
</code></pre>
<p><code>which</code> 함수는 함수 인자의 모든 <code>TRUE</code> 요소에 대한 색인을 반환한다. 함수에 전달되기 전에 표현식이 평가됨을 기억한다. 내부를 파고들어, 어떤 일이 진행되는지 명확히 알아보자.</p>
<p>다음이 가장 먼저 진행된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) ==<span class="st"> &quot;a&quot;</span></code></pre></div>
<pre class="output"><code>[1]  TRUE FALSE FALSE FALSE FALSE
</code></pre>
<p>조건 연산자는 <code>x</code> 벡터에 대한 모든 명칭에 적용된다. 첫번째 명칭만 “a” 라서, 해당 요소만 참(TRUE)이 된다.</p>
<p>그리고 나면, <code>which</code>가 이를 색인으로 변환한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;a&quot;</span>)</code></pre></div>
<pre class="output"><code>[1] 1
</code></pre>
<p>첫번째 요소만 <code>참(TRUE)</code>이라서, <code>which</code>는 1을 반환한다. 이제 색인을 갖게 되서, 건너뛰는 연산이 동작한다. 왜냐하면 음수 색인이기 때문이다!</p>
<p>명칭을 갖는 다수 색인을 건너뛰는 것도 유사하다. 하지만, 다른 비교 연산자를 사용한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>))]</code></pre></div>
<pre class="output"><code>  b   d   e 
6.2 4.8 7.5 
</code></pre>
<p><code>%in%</code> 비교연산자는 좌측 인자(이번 경우에, <code>x</code> 명칭)에 대한 각 요소를 훑는다. 그리고 나서, “해당 요소가 두번째 인자에 나타나는가?”라고 질의한다.</p>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-2"><span class="glyphicon glyphicon-pencil"></span>도전과제 2</h2>
</div>
<div class="panel-body">
<p>다음 코드를 실행해서 <code>x</code> 벡터를 정의한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p><code>x</code> 벡터가 주어지면, 다음 명령어는 어떤 작업을 수행할 것으로 예상되는가?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;g&quot;</span>)]</code></pre></div>
<p>상기 명령어를 시도해보고, 실행결과를 살펴본다. 여러분의 예상과 일치하는가? 왜 이런 결과가 나왔을까? (Tip: 여러분이 직접 작성한 것처럼 한땀한땀 명령어 각각을 테스트한다 - 매우 유용한 디버깅 전략이다.)</p>
<p>다음 중 어떤 것이 사실인가:</p>
<ul>
<li><ol style="list-style-type: upper-alpha">
<li><code>which</code>에 전달되는 <code>TRUE</code>값이 없다면, 공벡터가 반환된다.</li>
</ol></li>
<li><ol start="2" style="list-style-type: upper-alpha">
<li><code>which</code>에 전달되는 <code>TRUE</code>값이 없다면, 오류 메시지가 나타난다.</li>
</ol></li>
<li><ol start="3" style="list-style-type: upper-alpha">
<li><code>integer()</code>는 공벡터다.</li>
</ol></li>
<li><ol start="4" style="list-style-type: upper-alpha">
<li>공벡터를 부정하면 “모든” 벡터를 만들어낸다.</li>
</ol></li>
<li><ol start="5" style="list-style-type: upper-alpha">
<li><code>x[]</code>은 <code>x[integer()]</code>와 동일한 결과를 산출한다.</li>
</ol></li>
</ul>
</div>
</section>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-유일무이하지-않은-명칭"><span class="glyphicon glyphicon-pushpin"></span>Tip: 유일무이하지 않은 명칭</h2>
</div>
<div class="panel-body">
<p>벡터에 요소 다수가 동일 명칭을 갖을 수 있음에 유의해야만 된다. (데이터프레임에서, 칼럼이 동일한 명칭을 갖을 수 있다 — R이 이런 점을 회피하려고 하지만 — 하지만, 행 명칭은 유일무이해야 된다.) 다음 예제를 고려해보자:</p>
</div>
</aside>
<blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">3</span>
x</code></pre></div>
<pre class="output"><code>[1] 1 2 3
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>)  
x</code></pre></div>
<pre class="output"><code>a a a 
1 2 3 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="st">&#39;a&#39;</span>]  <span class="co"># 첫번째 값만 반환한다.</span></code></pre></div>
<pre class="output"><code>a 
1 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &#39;a&#39;</span>)]  <span class="co"># 세가지 값 모두 반환한다.</span></code></pre></div>
<pre class="output"><code>a a a 
1 2 3 
</code></pre>
</blockquote>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-연산자에-대한-도움말-얻기"><span class="glyphicon glyphicon-pushpin"></span>Tip: 연산자에 대한 도움말 얻기</h2>
</div>
<div class="panel-body">
<p>인용부호 내부에 찾고자 하는 연산자를 감싸서 도움말을 검색할 수 있다: <code>help(&quot;%in%&quot;)</code> 혹은 <code>?&quot;%in%&quot;</code>.</p>
</div>
</aside>
<p>그러면, 이전처럼 <code>==</code> 연산자는 왜 사용할 수 없을까? 매우 좋은 질문이다.</p>
<p>비교에 해당되는 항목만 살펴보자:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) ==<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>)</code></pre></div>
<pre class="error"><code>Warning in names(x) == c(&quot;a&quot;, &quot;c&quot;): 두 객체의 길이가 서로 배수관계에 있지
않습니다
</code></pre>
<pre class="output"><code>[1]  TRUE FALSE  TRUE
</code></pre>
<p>분명히, “c”는 <code>x</code> 요소명칭 중에 존재한다. 그런데, 왜 동작을 하지 않을까? <code>==</code>은 <code>%in%</code> 과는 다소 다른방식으로 동작한다. <code>==</code>은 좌측 인자 요소 각각을 대응되는 우측 요소 각각과 비교한다.</p>
<p><code>==</code> 연산자를 모사한 것이 다음에 나와 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;e&quot;</span>)  <span class="co"># x 명칭</span>
   |<span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="co"># ==으로 요소들을 비교한다.</span>
<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>)</code></pre></div>
<p>한 벡터가 다른 벡터보다 작은 경우, 해당 벡터는 <em>재사용</em>된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;e&quot;</span>)  <span class="co"># x 명칭</span>
   |<span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="er">|</span><span class="st">    </span><span class="co"># ==으로 요소들을 비교한다.</span>
<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>)</code></pre></div>
<p>이런 경우, R이 단순히 <code>c(&quot;a&quot;, &quot;c&quot;)</code>을 두번 반복한다. 더 긴 벡터가 더 짧은 벡터의 배수가 아닌 경우, R은 경고 메시지도 출력한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(x) ==<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;e&#39;</span>)</code></pre></div>
<pre class="output"><code>[1]  TRUE FALSE FALSE
</code></pre>
<p><code>==</code> 와 <code>%in%</code> 차이점을 숙지하는 것이 중요한데, 이유는 탐지가 어렵고 미묘한 버그가 스며들 수 있기 때문이다!</p>
<h2 id="논리-연산자를-통한-부분집합-뽑아내기">논리 연산자를 통한 부분집합 뽑아내기</h2>
<p>더 단순하게는 논리 연산자로 부분집합을 뽑아낼 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>)]</code></pre></div>
<pre class="output"><code>a a 
1 2 
</code></pre>
<p>이번 경우, 논리 벡터는 부분집합을 뽑아내는 벡터 길이만큼 재사용됨에 주목한다!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]</code></pre></div>
<pre class="output"><code>a a 
1 3 
</code></pre>
<p>비교 연산자는 논리벡터로 평가되기 때문에, 간결하게 벡터 부분집합을 뽑아내는데 사용할 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[x &gt;<span class="st"> </span><span class="dv">7</span>]</code></pre></div>
<pre class="output"><code>named integer(0)
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-논리-연산자-연쇄-체인-구성"><span class="glyphicon glyphicon-pushpin"></span>Tip: 논리 연산자 연쇄 체인 구성</h2>
</div>
<div class="panel-body">
<p>다수 조건을 조합하고자 하는 상황이 많이 있다. 이런 작업을 수행하는데 필요한 논리 연산자가 R에서 지원된다:</p>
<ul>
<li><code>|</code> 논리 OR: 왼쪽 오른쪽 어느 한쪽이 <code>TRUE</code>면, <code>TRUE</code>를 반환한다.</li>
<li><code>&amp;</code> 논리 AND: 왼쪽 오른쪽 모두가 <code>TRUE</code>면, <code>TRUE</code>를 반환한다.</li>
<li><code>!</code> 논리 NOT: <code>TRUE</code>는 <code>FALSE</code>로, <code>FALSE</code>는 <code>TRUE</code>로 전환한다.</li>
<li><code>&amp;&amp;</code> , <code>||</code> 은 두 벡터의 개별 요소를 비교한다. 재활용 규칙은 이곳도 적용된다.</li>
</ul>
</div>
</aside>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-3"><span class="glyphicon glyphicon-pencil"></span>도전과제 3</h2>
</div>
<div class="panel-body">
<p>다음 코드가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p><code>x</code> 벡터에서 4보다 크고 7보다 적은 값을 부분집합으로 뽑아내는 명령어를 작성한다.</p>
</div>
</section>
<h2 id="특수값-처리하기">특수값 처리하기</h2>
<p>어느 지점에 다다르면, R 함수에 처리할 수 없는 결측값, 무한값, 정의되지 않는 값을 갖는 데이터와 마주하게 된다.</p>
<p>이런 유형의 데이터를 필터링하는데 사용되는 특수 함수가 있다:</p>
<ul>
<li><code>is.na</code>는 벡터, 행렬, 데이터프레임에 포함된 <code>NA</code> 위치를 반환한다.</li>
<li>마찬가지로, <code>is.nan</code> 와 <code>is.infinite</code> 함수도 <code>NaN</code> 와 <code>Inf</code> 값에 대한 동일한 작업을 수행한다.</li>
<li><code>is.finite</code> 함수는 <code>NA</code>, <code>NaN</code>, <code>Inf</code> 값을 포함하지 않는 벡터, 행렬, 데이터프레임에 대한 모든 위치정보를 반환한다.</li>
<li><code>na.omit</code>는 벡터에서 모든 결측값을 필터링해서 제외시키다.</li>
</ul>
<h2 id="요인-부분집합으로-뽑아내기">요인 부분집합으로 뽑아내기</h2>
<p>지금까지 벡터 부분집합을 뽑아내는 다양한 방식을 탐색했다. 다른 자료구조에 대한 부분집합은 어떻게 뽑아낼 수 있을까?</p>
<p>요인 부분집합 뽑아내기는 벡터 부분집합 뽑아내기와 동일한 방식으로 동작한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>))
f[f ==<span class="st"> &quot;a&quot;</span>]</code></pre></div>
<pre class="output"><code>[1] a a
Levels: a b c d
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f[f %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)]</code></pre></div>
<pre class="output"><code>[1] b c c
Levels: a b c d
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f[<span class="dv">1</span>:<span class="dv">3</span>]</code></pre></div>
<pre class="output"><code>[1] a a b
Levels: a b c d
</code></pre>
<p>중요한 주의점 하나는 건너뛰는 요소가 설사 해당 범주가 요인으로 존재하지 않더라도, 수준(level)을 제거하지 않는다는 점이다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f[-<span class="dv">3</span>]</code></pre></div>
<pre class="output"><code>[1] a a c c d
Levels: a b c d
</code></pre>
<h2 id="행렬-부분집합-뽑아내기">행렬 부분집합 뽑아내기</h2>
<p>행렬의 경우도 <code>[</code> 함수를 사용해서 부분집합을 뽑아낸다. 이번 경우에는 인자를 두개 사용한다: 첫번째 인자는 행에 적용되고, 두번째 인자는 칼럼에 적용된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">6</span>*<span class="dv">4</span>), <span class="dt">ncol=</span><span class="dv">4</span>, <span class="dt">nrow=</span><span class="dv">6</span>)
m[<span class="dv">3</span>:<span class="dv">4</span>, <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>)]</code></pre></div>
<pre class="output"><code>            [,1]       [,2]
[1,]  1.12493092 -0.8356286
[2,] -0.04493361  1.5952808
</code></pre>
<p>첫번째 혹은 두번째 인자를 공백으로 남겨놓을 수도 있는데, 모든 행 혹은 칼럼을 각각 불러올 경우 사용한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[, <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>)]</code></pre></div>
<pre class="output"><code>            [,1]        [,2]
[1,] -0.62124058  0.82122120
[2,] -2.21469989  0.59390132
[3,]  1.12493092  0.91897737
[4,] -0.04493361  0.78213630
[5,] -0.01619026  0.07456498
[6,]  0.94383621 -1.98935170
</code></pre>
<p>행 혹은 칼럼 하나만 접근하고자 하면, R이 자동으로 결과값을 벡터로 전환시킨다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[<span class="dv">3</span>,]</code></pre></div>
<pre class="output"><code>[1] -0.8356286  0.5757814  1.1249309  0.9189774
</code></pre>
<p>결과값을 행렬로 그대로 유지하고자 한다면, <em>세번째</em> 인자를 명세할 필요가 있다; <code>drop = FALSE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[<span class="dv">3</span>, , drop=<span class="ot">FALSE</span>]</code></pre></div>
<pre class="output"><code>           [,1]      [,2]     [,3]      [,4]
[1,] -0.8356286 0.5757814 1.124931 0.9189774
</code></pre>
<p>벡터와 달리, 행렬 외부 행과 칼럼을 접근하고자 하면, R이 오류를 던진다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[, <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">6</span>)]</code></pre></div>
<pre class="error"><code>Error in m[, c(3, 6)]: 첨자의 허용 범위를 벗어났습니다
</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="tip-고차원-배열"><span class="glyphicon glyphicon-pushpin"></span>Tip: 고차원 배열</h2>
</div>
<div class="panel-body">
<p>다차원 배열을 다룰 때, <code>[</code>에 넘겨지는 각 인자가 차원에 대응된다. 예를 들어, 3D 배열에서 첫세개 인자는 각각 행, 열, 깊이 차원에 대응된다.</p>
</div>
</aside>
<p>행렬을 까면 정말 자료형이 벡터라서, 단지 인자 하나로만 부분집합을 추출할 수도 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m[<span class="dv">5</span>]</code></pre></div>
<pre class="output"><code>[1] 0.3295078
</code></pre>
<p>보통 유용하지는 않다. 하지만, 행렬이 <em>열우선형식(column-major format)</em>으로 기본디폴트 설정으로 되어있음에 주목한다. 즉, 벡터 요소가 칼럼방향으로 배열된다는 것을 의미한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">6</span>, <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">ncol=</span><span class="dv">3</span>)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
</code></pre>
<p>행렬을 행우선으로 쭉 펼치고자 한다면, <code>byrow=TRUE</code>를 사용한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">6</span>, <span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">ncol=</span><span class="dv">3</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
</code></pre>
<p>행과 칼럼 색인 대신에 행명칭(rownames)과 열명칭(column names)을 사용해서 배열 부분집합을 뽑아낼 수 있다.</p>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-4"><span class="glyphicon glyphicon-pencil"></span>도전과제 4</h2>
</div>
<div class="panel-body">
<p>다음과 같은 코드가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">18</span>, <span class="dt">nrow=</span><span class="dv">3</span>, <span class="dt">ncol=</span><span class="dv">6</span>)
<span class="kw">print</span>(m)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    4    7   10   13   16
[2,]    2    5    8   11   14   17
[3,]    3    6    9   12   15   18
</code></pre>
<ol style="list-style-type: decimal">
<li>다음 중 어떤 명령어가 값 11과 14를 추출하는 하는가?</li>
</ol>
<p>A. <code>m[2,4,2,5]</code></p>
<p>B. <code>m[2:5]</code></p>
<p>C. <code>m[4:5,2]</code></p>
<p>D. <code>m[2,c(4,5)]</code></p>
</div>
</section>
<h2 id="리스트-부분집합-뽑아내기">리스트 부분집합 뽑아내기</h2>
<p>이제 몇가지 새로운 부분집합을 뽑아내는 연산자를 소개한다. 리스트 부분집합을 뽑아내는데 사용되는 함수가 세가지 있다; 원자벡터와 행렬에서 살펴본 <code>[</code>, 그리고 <code>[[</code>, <code>$</code>이 있다.</p>
<p><code>[</code>을 사용하면, 항상 리스트만 반환한다. 리스트 <em>부분집합을 뽑아내고자</em> 하지만, 요소는 뽑아내고 <em>싶지 않다면</em>, 아마도 <code>[</code> 연산자를 사용할 것이다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="st">&quot;Software Carpentry&quot;</span>, <span class="dt">b =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">data =</span> <span class="kw">head</span>(iris))
xlist[<span class="dv">1</span>]</code></pre></div>
<pre class="output"><code>$a
[1] &quot;Software Carpentry&quot;
</code></pre>
<p>상기 명령어는 <em>요소 하나만 갖는 리스트</em>를 반환한다.</p>
<p><code>[</code> 연산자를 사용해서 원자벡터에 적용한 그대로 리스트 요소를 부분집합으로 뽑아낼 수 있다. 하지만, 리스트가 재귀적으로 되어 있지 않다면, 비교 연산자는 동작하지 않는다. 이유는 비교 연산자가 데이터 구조 내부 개별 요소가 아닌, 리스트 각 요소에 내재한 자료구조로 되어있기 때문이다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[<span class="dv">1</span>:<span class="dv">2</span>]</code></pre></div>
<pre class="output"><code>$a
[1] &quot;Software Carpentry&quot;

$b
 [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>
<p>리스트 개별 요소를 추출하려면, 이중 꺾쇠 함수를 사용한다: <code>[[</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[<span class="dv">1</span>]]</code></pre></div>
<pre class="output"><code>[1] &quot;Software Carpentry&quot;
</code></pre>
<p>이제 결과값이 리스트가 아닌 벡터에 주목한다.</p>
<p>한번에 요소 하나이상을 추출할 수는 없다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[<span class="dv">1</span>:<span class="dv">2</span>]]</code></pre></div>
<pre class="error"><code>Error in xlist[[1:2]]: 첨자의 허용 범위를 벗어났습니다
</code></pre>
<p>요소를 건너뛰는 것도 사용할 수 없다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[-<span class="dv">1</span>]]</code></pre></div>
<pre class="error"><code>Error in xlist[[-1]]: 한 개 이상의 구성요소 선택을 시도합니다
</code></pre>
<p>하지만, 명칭을 사용해서 요소에 대한 부분집합으로 뽑아내거나, 요소를 추출할 때 사용할 수 있다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist[[<span class="st">&quot;a&quot;</span>]]</code></pre></div>
<pre class="output"><code>[1] &quot;Software Carpentry&quot;
</code></pre>
<p><code>$</code> 함수는 명칭으로 요소를 뽑아내는데 사용되는 초간편 방법이다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist$data</code></pre></div>
<pre class="output"><code>  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전-과제-5"><span class="glyphicon glyphicon-pencil"></span>도전 과제 5</h2>
</div>
<div class="panel-body">
<p>다음 리스트가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="st">&quot;Software Carpentry&quot;</span>, <span class="dt">b =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">data =</span> <span class="kw">head</span>(iris))</code></pre></div>
<p>리스트와 벡터 부분집합을 추출하는 지식을 활용해서, <code>xlist</code>에서 숫자 2를 추출한다. <strong>힌트:</strong> 숫자 2는 리스트 “b” 항목 내부에 담겨있다.</p>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전-과제-6"><span class="glyphicon glyphicon-pencil"></span>도전 과제 6</h2>
</div>
<div class="panel-body">
<p>선형 모형이 다음과 같이 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">aov</span>(pop ~<span class="st"> </span>lifeExp, <span class="dt">data=</span>gapminder)</code></pre></div>
<p>잔차 자유도를 추출하라. <strong>힌트:</strong> <code>attributes()</code> 함수가 도움을 줄 것이다.</p>
</div>
</section>
<h2 id="데이터프레임">데이터프레임</h2>
<p>데이터프레임을 까면 내부는 리스트로 구성된 것을 기억한다. 그래서 유사한 규칙이 적용된다. 하지만, 데이터프레임도 2차원 객체다:</p>
<p><code>[</code>함수에 인자를 하나만 넣으면 리스트와 동일하게 동작한다. 즉, 각 리스트 요소는 칼럼에 대응된다. 작업결과 나오는 객체는 데이터프레임이다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(gapminder[<span class="dv">3</span>])</code></pre></div>
<pre class="output"><code>       pop
1  8425333
2  9240934
3 10267083
4 11537966
5 13079460
6 14880372
</code></pre>
<p>유사하게, <code>[[</code> 함수는 <em>칼럼 한개</em>만 추출하는데 동작된다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(gapminder[[<span class="st">&quot;lifeExp&quot;</span>]])</code></pre></div>
<pre class="output"><code>[1] 28.801 30.332 31.997 34.020 36.088 38.438
</code></pre>
<p>명칭으로 칼럼을 추출하는데 사용되는 편리한 단축어가 <code>$</code>이다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(gapminder$year)</code></pre></div>
<pre class="output"><code>[1] 1952 1957 1962 1967 1972 1977
</code></pre>
<p>인자가 두개 있는 경우, <code>[</code> 함수는 행렬에 대해서와 마찬가지로 동작한다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[<span class="dv">1</span>:<span class="dv">3</span>,]</code></pre></div>
<pre class="output"><code>      country year      pop continent lifeExp gdpPercap
1 Afghanistan 1952  8425333      Asia  28.801  779.4453
2 Afghanistan 1957  9240934      Asia  30.332  820.8530
3 Afghanistan 1962 10267083      Asia  31.997  853.1007
</code></pre>
<p>행 하나만 부분집합으로 뽑아내면, 결과는 데이터프레임이 되는데 이유는 각 요소가 혼합된 자료형으로 구성되었기 때문이다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[<span class="dv">3</span>,]</code></pre></div>
<pre class="output"><code>      country year      pop continent lifeExp gdpPercap
3 Afghanistan 1962 10267083      Asia  31.997  853.1007
</code></pre>
<p>하지만, 단일 칼럼에 대해서 결과는 벡터다. <code>drop = FALSE</code>를 세번째 인자로 넣으면 바꿀 수 있다.</p>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-7"><span class="glyphicon glyphicon-pencil"></span>도전과제 7</h2>
</div>
<div class="panel-body">
<p>데이터프레임 부분집합을 뽑아내는 오류가 다음에 나와 있는데 이를 버그없이 수정하라:</p>
<ol style="list-style-type: decimal">
<li>1957년에 수집된 관측점을 뽑아내라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[gapminder$year =<span class="st"> </span><span class="dv">1957</span>,]</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>1에서 4를 제외한 모든 칼럼을 뽑아내라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[,-<span class="dv">1</span>:<span class="dv">4</span>]</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>기대수명이 80세 이상 되는 행을 추출하라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[gapminder$lifeExp &gt;<span class="st"> </span><span class="dv">80</span>]</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>첫번째 행과 4번째 5번째 칼럼(<code>lifeExp</code>, <code>gdpPercap</code>)을 뽑아내라. .</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>]</code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>고급: 2002년과 2007년에 대한 정보를 담고 있는 행을 추출하라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder[gapminder$year ==<span class="st"> </span><span class="dv">2002</span> |<span class="st"> </span><span class="dv">2007</span>,]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-8"><span class="glyphicon glyphicon-pencil"></span>도전과제 8</h2>
</div>
<div class="panel-body">
<ol style="list-style-type: decimal">
<li><p><code>gapminder[1:20]</code> 명령어는 왜 오류를 반환하는가? <code>gapminder[1:20,]</code>와 어떻게 다른가?</p></li>
<li><p><code>gapminder_small</code>이라는 데이터프레임을 생성하는데 1에서 9까지 행과 19에서 23까지 행만 포함한다. 이 작업을 하나 혹은 두 단계로 작성한다.</p></li>
</ol>
</div>
</section>
<h2 id="도전과제-해답">도전과제 해답</h2>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-1에-대한-해답"><span class="glyphicon glyphicon-pencil"></span>도전과제 1에 대한 해답</h2>
</div>
<div class="panel-body">
<p>다음과 같은 코드가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<ol style="list-style-type: decimal">
<li>다음 출력결과를 산출하는 적어도 서로 다른 명령어 3개를 제시한다:</li>
</ol>
<pre class="output"><code>  b   c   d 
6.2 7.1 4.8 
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">2</span>:<span class="dv">4</span>] 
x[-<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">5</span>)]
x[<span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>)]
x[<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-2에-대한-해답"><span class="glyphicon glyphicon-pencil"></span>도전과제 2에 대한 해답</h2>
</div>
<div class="panel-body">
<p>다음 코드를 실행해서 <code>x</code> 벡터를 정의한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">5.4</span>, <span class="fl">6.2</span>, <span class="fl">7.1</span>, <span class="fl">4.8</span>, <span class="fl">7.5</span>)
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre class="output"><code>  a   b   c   d   e 
5.4 6.2 7.1 4.8 7.5 
</code></pre>
<p><code>x</code> 벡터가 주어지면, 다음 명령어는 어떤 작업을 수행할 것으로 예상되는가?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[-<span class="kw">which</span>(<span class="kw">names</span>(x) ==<span class="st"> &quot;g&quot;</span>)]</code></pre></div>
<p>상기 명령어를 시도해보고, 실행결과를 살펴본다. 여러분의 예상과 일치하는가? 왜 이런 결과가 나왔을까? (Tip: 여러분이 직접 작성한 것처럼 한땀한땀 명령어 각각을 테스트한다 - 매우 유용한 디버깅 전략이다.)</p>
<p>다음 중 어떤 것이 사실인가:</p>
<ul>
<li><ol style="list-style-type: upper-alpha">
<li><code>which</code>에 전달되는 <code>TRUE</code>값이 없다면, 공벡터가 반환된다.</li>
</ol></li>
<li><ol start="2" style="list-style-type: upper-alpha">
<li><code>which</code>에 전달되는 <code>TRUE</code>값이 없다면, 오류 메시지가 나타난다.</li>
</ol></li>
<li><ol start="3" style="list-style-type: upper-alpha">
<li><code>integer()</code>는 공벡터다.</li>
</ol></li>
<li><ol start="4" style="list-style-type: upper-alpha">
<li>공벡터를 부정하면 “모든” 벡터를 만들어낸다.</li>
</ol></li>
<li><ol start="5" style="list-style-type: upper-alpha">
<li><code>x[]</code>은 <code>x[integer()]</code>와 동일한 결과를 산출한다.</li>
</ol></li>
</ul>
<p>정답: A 와 C 가 맞다.</p>
<p><code>which</code> 명령어는 입력값에 대한 모든 <code>TRUE</code> 값에 대한 색인을 반환한다. <code>names(x) == &quot;g&quot;</code>은 어떤 <code>TRUE</code>값도 반환하지 않는다. <code>which</code> 명령어에 전달되는 어떤 <code>TRUE</code> 값도 없기 때문에, 공벡터를 반환했다. 음수 부호로 벡터를 부정한다고 의미가 변경되지는 않는다. <code>x</code> 벡터에서 값을 가져오는데 공벡터를 사용했기 때문에, 빈 숫자벡터를 만들어 낸다. 결과는 <code>named numeric</code> 공벡터다. 이유는 <code>x</code> 벡터 자료형이 “named numeric”인데, 명칭을 값에 대입했기 때문이다(<code>str(x)</code>을 시도해 보라).</p>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-4에-대한-해답"><span class="glyphicon glyphicon-pencil"></span>도전과제 4에 대한 해답</h2>
</div>
<div class="panel-body">
<p>다음과 같은 코드가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">18</span>, <span class="dt">nrow=</span><span class="dv">3</span>, <span class="dt">ncol=</span><span class="dv">6</span>)
<span class="kw">print</span>(m)</code></pre></div>
<pre class="output"><code>     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    4    7   10   13   16
[2,]    2    5    8   11   14   17
[3,]    3    6    9   12   15   18
</code></pre>
<ol style="list-style-type: decimal">
<li>다음 중 어떤 명령어가 값 11과 14를 추출하는 하는가?</li>
</ol>
<p>A. <code>m[2,4,2,5]</code></p>
<p>B. <code>m[2:5]</code></p>
<p>C. <code>m[4:5,2]</code></p>
<p>D. <code>m[2,c(4,5)]</code></p>
<p>정답: D</p>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-5에-대한-해답"><span class="glyphicon glyphicon-pencil"></span>도전과제 5에 대한 해답</h2>
</div>
<div class="panel-body">
<p>다음 리스트가 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="st">&quot;Software Carpentry&quot;</span>, <span class="dt">b =</span> <span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">data =</span> <span class="kw">head</span>(iris))</code></pre></div>
<p>리스트와 벡터 부분집합을 추출하는 지식을 활용해서, <code>xlist</code>에서 숫자 2를 추출한다. <strong>힌트:</strong> 숫자 2는 리스트 “b” 항목 내부에 담겨있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xlist$b[<span class="dv">2</span>]
xlist[[<span class="dv">2</span>]][<span class="dv">2</span>]
xlist[[<span class="st">&quot;b&quot;</span>]][<span class="dv">2</span>]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-6에-대한-해답"><span class="glyphicon glyphicon-pencil"></span>도전과제 6에 대한 해답</h2>
</div>
<div class="panel-body">
<p>선형 모형이 다음과 같이 주어졌다:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">aov</span>(pop ~<span class="st"> </span>lifeExp, <span class="dt">data=</span>gapminder)</code></pre></div>
<p>잔차 자유도를 추출하라. <strong>힌트:</strong> <code>attributes()</code> 함수가 도움을 줄 것이다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attributes</span>(mod) ## `df.residual` is one of the names of `mod`
mod$df.residual</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-7에-대한-해답"><span class="glyphicon glyphicon-pencil"></span>도전과제 7에 대한 해답</h2>
</div>
<div class="panel-body">
<p>데이터프레임 부분집합을 뽑아내는 오류가 다음에 나와 있는데 이를 버그없이 수정하라:</p>
<ol style="list-style-type: decimal">
<li>1957년에 수집된 관측점을 뽑아내라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[gapminder$year = 1957,]</span>
gapminder[gapminder$year ==<span class="st"> </span><span class="dv">1957</span>,]</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>1에서 4를 제외한 모든 칼럼을 뽑아내라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[,-1:4]</span>
gapminder[,-<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">4</span>)]</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>기대수명이 80세 이상 되는 행을 추출하라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[gapminder$lifeExp &gt; 80]</span>
gapminder[gapminder$lifeExp &gt;<span class="st"> </span><span class="dv">80</span>,]</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>첫번째 행과 4번째 5번째 칼럼(<code>lifeExp</code>, <code>gdpPercap</code>)을 뽑아내라. .</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[1, 4, 5]</span>
gapminder[<span class="dv">1</span>, <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">5</span>)]</code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>고급: 2002년과 2007년에 대한 정보를 담고 있는 행을 추출하라.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># gapminder[gapminder$year == 2002 | 2007,]</span>
gapminder[gapminder$year ==<span class="st"> </span><span class="dv">2002</span> |<span class="st"> </span>gapminder$year ==<span class="st"> </span><span class="dv">2007</span>,]
gapminder[gapminder$year %in%<span class="st"> </span><span class="kw">c</span>(<span class="dv">2002</span>, <span class="dv">2007</span>),]</code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="도전과제-8에-대한-해답"><span class="glyphicon glyphicon-pencil"></span>도전과제 8에 대한 해답</h2>
</div>
<div class="panel-body">
<ol style="list-style-type: decimal">
<li><code>gapminder[1:20]</code> 명령어는 왜 오류를 반환하는가? <code>gapminder[1:20,]</code>와 어떻게 다른가?</li>
</ol>
<p>정답: <code>gapminder</code>는 데이터프레임이다. 그래서 차원 2개로 부분집합을 뽑아낼 필요가 있다. <code>gapminder[1:20, ]</code>는 첫번째부터 20번째 모든 행과 모든 칼럼을 부분집합으로 뽑아낸다.</p>
<ol start="2" style="list-style-type: decimal">
<li><code>gapminder_small</code>이라는 데이터프레임을 생성하는데 1에서 9까지 행과 19에서 23까지 행만 포함한다. 이 작업을 하나 혹은 두 단계로 작성한다.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gapminder_small &lt;-<span class="st"> </span>gapminder[<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">9</span>, <span class="dv">19</span>:<span class="dv">23</span>),]</code></pre></div>
</div>
</section>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/lesson-template">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
